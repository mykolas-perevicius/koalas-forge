#!/usr/bin/env python3
"""
üê® Koala's Forge CLI Tool
A powerful command-line interface for managing your app installations.

Usage:
  koala install <app1> <app2> ...     Install applications
  koala update [app1] [app2] | --all  Update applications
  koala uninstall <app1> <app2>       Uninstall applications
  koala list [--installed]            List available or installed apps
  koala search <term>                 Search for applications

  koala rollback list                 List rollback snapshots
  koala rollback create <name>        Create a new snapshot
  koala rollback restore <id>         Restore to a snapshot

  koala plugin list                   List loaded plugins
  koala plugin load <path>            Load a plugin
  koala plugin reload <name>          Reload a plugin

  koala sync push                     Push profile to cloud
  koala sync pull                     Pull profile from cloud
  koala sync status                   Check sync status

  koala events                        Show recent events
  koala status                        Show system status
  koala version                       Show version info
"""

import sys
import asyncio
import argparse
from pathlib import Path
from typing import List, Optional
import json

# Add src to path
sys.path.insert(0, str(Path(__file__).parent))

from src.core.event_system import EventBus, Event, EventType, get_event_bus
from src.core.plugin_system import PluginManager
from src.core.rollback_system import RollbackManager
from src.core.cloud_sync import CloudSyncManager
from src.core.installer import PackageInstaller, get_installer
from datetime import datetime


class KoalasCLI:
    """Main CLI application"""

    def __init__(self):
        self.event_bus = get_event_bus()
        self.plugin_manager = PluginManager(self.event_bus)
        self.rollback_manager = RollbackManager()
        self.cloud_sync = CloudSyncManager()
        self.installer = get_installer()
        self.version = "1.2.0"

    async def cmd_install(self, apps: List[str], yes: bool = False, dry_run: bool = False):
        """Install applications"""
        print(f"üê® Installing {len(apps)} application(s)...")

        if dry_run:
            print("üîç DRY RUN MODE - No actual changes will be made\n")

        # Create rollback point (unless dry run)
        if not dry_run:
            snapshot_id = await self.rollback_manager.create_snapshot(f"Before installing {', '.join(apps)}")
            print(f"üì∏ Created snapshot: {snapshot_id}\n")

        installed = []
        failed = []
        already_installed = []

        for app in apps:
            result = await self.installer.install(app, dry_run=dry_run)

            if result.get('success'):
                if result.get('already_installed'):
                    already_installed.append(app)
                else:
                    installed.append(app)
            else:
                failed.append((app, result.get('error', 'Unknown error')))
                print(f"  ‚ùå Failed to install {app}: {result.get('error')}")

        # Summary
        print(f"\n‚ú® Installation complete!")
        if installed:
            print(f"   Installed: {len(installed)} app(s)")
        if already_installed:
            print(f"   Already installed: {len(already_installed)} app(s)")
        if failed:
            print(f"   Failed: {len(failed)} app(s)")
            for app, error in failed:
                print(f"     - {app}: {error}")

    async def cmd_update(self, apps: Optional[List[str]] = None, all: bool = False):
        """Update applications"""
        if all:
            print("üê® Updating all installed applications...")
            # TODO: Get list of all installed apps
            print("  ‚ÑπÔ∏è  Update all not yet implemented")
            return

        if not apps:
            print("‚ùå Please specify apps to update or use --all")
            return

        print(f"üê® Updating {len(apps)} application(s)...")

        updated = []
        failed = []

        for app in apps:
            result = await self.installer.update(app)

            if result.get('success'):
                updated.append(app)
            else:
                failed.append((app, result.get('error', 'Unknown error')))

        # Summary
        print(f"\n‚ú® Update complete!")
        if updated:
            print(f"   Updated: {len(updated)} app(s)")
        if failed:
            print(f"   Failed: {len(failed)} app(s)")
            for app, error in failed:
                print(f"     - {app}: {error}")

    async def cmd_uninstall(self, apps: List[str], yes: bool = False):
        """Uninstall applications"""
        print(f"üê® Uninstalling {len(apps)} application(s)...")

        # Create rollback point
        snapshot_id = await self.rollback_manager.create_snapshot(f"Before uninstalling {', '.join(apps)}")
        print(f"üì∏ Created snapshot: {snapshot_id}\n")

        uninstalled = []
        failed = []
        not_installed = []

        for app in apps:
            result = await self.installer.uninstall(app)

            if result.get('success'):
                if result.get('not_installed'):
                    not_installed.append(app)
                else:
                    uninstalled.append(app)
            else:
                failed.append((app, result.get('error', 'Unknown error')))

        # Summary
        print(f"\n‚ú® Uninstall complete!")
        if uninstalled:
            print(f"   Uninstalled: {len(uninstalled)} app(s)")
        if not_installed:
            print(f"   Not installed: {len(not_installed)} app(s)")
        if failed:
            print(f"   Failed: {len(failed)} app(s)")
            for app, error in failed:
                print(f"     - {app}: {error}")

    async def cmd_search(self, query: str):
        """Search for applications"""
        results = self.installer.search_packages(query)

        if not results:
            print(f"No packages found matching '{query}'")
            return

        print(f"\nüîç Found {len(results)} package(s) matching '{query}':\n")
        print(f"{'Name':<30} {'Category':<20} {'Platforms'}")
        print("=" * 80)

        for pkg in results[:20]:  # Limit to 20 results
            platforms = ', '.join(pkg.platforms[:3])
            print(f"{pkg.name:<30} {pkg.category:<20} {platforms}")

            if pkg.notes:
                print(f"    {pkg.notes[:60]}")
                print()

        if len(results) > 20:
            print(f"\n... and {len(results) - 20} more results")

    async def cmd_list(self, category: Optional[str] = None, installed: bool = False):
        """List available or installed applications"""

        if installed:
            print("‚ÑπÔ∏è  Listing installed packages not yet implemented")
            return

        if category:
            print(f"\nüì¶ Packages in category '{category}':\n")
            packages = self.installer.list_packages(category=category)
        else:
            print(f"\nüì¶ All available packages:\n")
            packages = self.installer.list_packages()

        if not packages:
            print(f"No packages found")
            return

        # Group by category
        by_category = {}
        for pkg in packages:
            if pkg.category not in by_category:
                by_category[pkg.category] = []
            by_category[pkg.category].append(pkg)

        for cat, pkgs in sorted(by_category.items()):
            print(f"\n{cat.replace('_', ' ').title()} ({len(pkgs)} packages)")
            print("-" * 60)

            for pkg in pkgs[:10]:  # Limit per category
                platforms = ', '.join(pkg.platforms[:3])
                print(f"  ‚Ä¢ {pkg.name:<25} ({platforms})")

            if len(pkgs) > 10:
                print(f"    ... and {len(pkgs) - 10} more")

    async def cmd_categories(self):
        """List all package categories"""
        categories = self.installer.get_categories()

        print(f"\nüìÇ Available Categories ({len(categories)}):\n")

        for cat in categories:
            packages = self.installer.list_packages(category=cat)
            display_name = cat.replace('_', ' ').title()
            print(f"  ‚Ä¢ {display_name:<30} ({len(packages)} packages)")

        print(f"\nUse './koala list --category <name>' to see packages in a category")

    async def cmd_rollback_list(self):
        """List rollback snapshots"""
        snapshots = self.rollback_manager.list_snapshots()

        if not snapshots:
            print("No snapshots found. Create one with: koala rollback create <name>")
            return

        print(f"\nüì∏ Rollback Snapshots ({len(snapshots)})\n")
        print(f"{'ID':<25} {'Date':<20} {'Apps':<10} {'Description'}")
        print("=" * 80)

        for snapshot in snapshots:
            # Handle timestamp (could be string, float/unix timestamp, or datetime object)
            ts = snapshot['timestamp']
            if isinstance(ts, str):
                date = datetime.fromisoformat(ts).strftime('%Y-%m-%d %H:%M')
            elif isinstance(ts, (int, float)):
                date = datetime.fromtimestamp(ts).strftime('%Y-%m-%d %H:%M')
            else:
                date = ts.strftime('%Y-%m-%d %H:%M')

            apps_count = len(snapshot.get('installed_apps', []))
            desc = snapshot.get('description', 'No description')[:40]
            print(f"{snapshot['id']:<25} {date:<20} {apps_count:<10} {desc}")

    async def cmd_rollback_create(self, name: str):
        """Create a rollback snapshot"""
        snapshot_id = await self.rollback_manager.create_snapshot(name)
        print(f"‚úÖ Created snapshot: {snapshot_id}")
        print(f"   Description: {name}")

        # Get the snapshot to show details
        snapshots = self.rollback_manager.list_snapshots()
        snapshot = next((s for s in snapshots if s['id'] == snapshot_id), None)
        if snapshot:
            print(f"   Apps tracked: {len(snapshot.get('installed_apps', []))}")

    async def cmd_rollback_restore(self, snapshot_id: str):
        """Restore to a rollback snapshot"""
        print(f"üîÑ Restoring to snapshot: {snapshot_id}")

        result = await self.rollback_manager.rollback_to_snapshot(snapshot_id)

        if result['success']:
            print(f"‚úÖ Rollback successful!")
            print(f"   Removed: {len(result['removed'])} apps")
            print(f"   Added: {len(result['added'])} apps")

            if result['removed']:
                print("\n   Removed apps:")
                for app in result['removed']:
                    print(f"     - {app}")

            if result['added']:
                print("\n   Added apps:")
                for app in result['added']:
                    print(f"     + {app}")
        else:
            print(f"‚ùå Rollback failed: {result.get('error', 'Unknown error')}")

    async def cmd_plugin_list(self):
        """List loaded plugins"""
        await self.plugin_manager.load_all_plugins()
        plugins = self.plugin_manager.list_plugins()

        if not plugins:
            print("No plugins loaded. Add plugins to ~/.koalas-forge/plugins/")
            return

        print(f"\nüîå Loaded Plugins ({len(plugins)})\n")
        print(f"{'Name':<25} {'Version':<10} {'Status'}")
        print("=" * 60)

        for plugin in plugins:
            status = "‚úÖ Active" if plugin.get('enabled', True) else "‚è∏Ô∏è  Disabled"
            print(f"{plugin['name']:<25} {plugin.get('version', '1.0.0'):<10} {status}")

    async def cmd_plugin_load(self, path: str):
        """Load a plugin"""
        print(f"üîå Loading plugin: {path}")
        success = await self.plugin_manager.load_plugin(Path(path))

        if success:
            print(f"‚úÖ Plugin loaded successfully")
        else:
            print(f"‚ùå Failed to load plugin")

    async def cmd_plugin_reload(self, name: str):
        """Reload a plugin"""
        print(f"üîÑ Reloading plugin: {name}")
        success = await self.plugin_manager.reload_plugin(name)

        if success:
            print(f"‚úÖ Plugin reloaded successfully")
        else:
            print(f"‚ùå Failed to reload plugin")

    async def cmd_sync_status(self):
        """Check cloud sync status"""
        status = self.cloud_sync.get_status()

        print(f"\n‚òÅÔ∏è  Cloud Sync Status\n")
        print(f"Backend: {status['backend']}")
        print(f"Enabled: {'‚úÖ Yes' if status['enabled'] else '‚ùå No'}")
        print(f"Last sync: {status.get('last_sync', 'Never')}")

        if status['backend'] != 'none':
            print(f"Sync path: {status.get('sync_path', 'Not configured')}")

    async def cmd_sync_push(self):
        """Push profile to cloud"""
        print("‚òÅÔ∏è  Pushing profile to cloud...")

        # Create a profile from current state
        profile = {
            'name': 'current',
            'apps': [],  # Would get from system
            'timestamp': datetime.now().isoformat()
        }

        success = await self.cloud_sync.push_profile(profile)

        if success:
            print("‚úÖ Profile pushed to cloud successfully")
        else:
            print("‚ùå Failed to push profile")

    async def cmd_sync_pull(self):
        """Pull profile from cloud"""
        print("‚òÅÔ∏è  Pulling profile from cloud...")

        profile = await self.cloud_sync.pull_profile('current')

        if profile:
            print("‚úÖ Profile pulled from cloud successfully")
            print(f"   Apps: {len(profile.get('apps', []))}")
        else:
            print("‚ùå No profile found in cloud")

    async def cmd_events(self, limit: int = 20):
        """Show recent events"""
        history = self.event_bus.get_history(limit=limit)

        if not history:
            print("No events recorded yet.")
            return

        print(f"\nüìã Recent Events (last {len(history)})\n")
        print(f"{'Time':<20} {'Type':<30} {'Source':<15}")
        print("=" * 70)

        for event in history:
            time = datetime.fromisoformat(event.timestamp).strftime('%H:%M:%S')
            event_type = event.type.name if hasattr(event.type, 'name') else str(event.type)
            print(f"{time:<20} {event_type:<30} {event.source:<15}")

    async def cmd_status(self):
        """Show system status"""
        print(f"\nüê® Koala's Forge System Status\n")
        print(f"Version: {self.version}")

        # Event bus stats
        stats = self.event_bus.get_stats()
        print(f"\nEvent System:")
        print(f"  Handlers: {stats['sync_handlers']} sync, {stats['async_handlers']} async")
        print(f"  Events processed: {len(self.event_bus.get_history())}")

        # Plugins
        await self.plugin_manager.load_all_plugins()
        plugins = self.plugin_manager.list_plugins()
        print(f"\nPlugins:")
        print(f"  Loaded: {len(plugins)}")

        # Snapshots
        snapshots = self.rollback_manager.list_snapshots()
        print(f"\nRollback:")
        print(f"  Snapshots: {len(snapshots)}")

        # Sync
        sync_status = self.cloud_sync.get_status()
        print(f"\nCloud Sync:")
        print(f"  Backend: {sync_status['backend']}")
        print(f"  Enabled: {sync_status['enabled']}")

    def cmd_version(self):
        """Show version info"""
        print(f"üê® Koala's Forge v{self.version}")
        print(f"Event-Driven Architecture Release")
        print(f"\nFeatures:")
        print(f"  ‚úÖ Event System")
        print(f"  ‚úÖ Plugin System")
        print(f"  ‚úÖ Rollback System")
        print(f"  ‚úÖ Parallel Downloads")
        print(f"  ‚úÖ Cloud Sync")


async def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(
        description='üê® Koala\'s Forge - Modern application installer',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__
    )

    subparsers = parser.add_subparsers(dest='command', help='Command to run')

    # Install command
    install_parser = subparsers.add_parser('install', help='Install applications')
    install_parser.add_argument('apps', nargs='+', help='Applications to install')
    install_parser.add_argument('-y', '--yes', action='store_true', help='Skip confirmations')
    install_parser.add_argument('--dry-run', action='store_true', help='Simulate installation without making changes')

    # Update command
    update_parser = subparsers.add_parser('update', help='Update applications')
    update_parser.add_argument('apps', nargs='*', help='Applications to update')
    update_parser.add_argument('--all', action='store_true', help='Update all installed applications')

    # Uninstall command
    uninstall_parser = subparsers.add_parser('uninstall', help='Uninstall applications')
    uninstall_parser.add_argument('apps', nargs='+', help='Applications to uninstall')
    uninstall_parser.add_argument('-y', '--yes', action='store_true', help='Skip confirmations')

    # Search command
    search_parser = subparsers.add_parser('search', help='Search for applications')
    search_parser.add_argument('query', help='Search query')

    # List command
    list_parser = subparsers.add_parser('list', help='List available applications')
    list_parser.add_argument('--category', help='Filter by category')
    list_parser.add_argument('--installed', action='store_true', help='List only installed applications')

    # Categories command
    subparsers.add_parser('categories', help='List all categories')

    # Rollback commands
    rollback_parser = subparsers.add_parser('rollback', help='Rollback operations')
    rollback_subparsers = rollback_parser.add_subparsers(dest='rollback_cmd')

    rollback_subparsers.add_parser('list', help='List snapshots')

    rollback_create = rollback_subparsers.add_parser('create', help='Create snapshot')
    rollback_create.add_argument('name', help='Snapshot description')

    rollback_restore = rollback_subparsers.add_parser('restore', help='Restore snapshot')
    rollback_restore.add_argument('id', help='Snapshot ID')

    # Plugin commands
    plugin_parser = subparsers.add_parser('plugin', help='Plugin operations')
    plugin_subparsers = plugin_parser.add_subparsers(dest='plugin_cmd')

    plugin_subparsers.add_parser('list', help='List plugins')

    plugin_load = plugin_subparsers.add_parser('load', help='Load plugin')
    plugin_load.add_argument('path', help='Plugin file path')

    plugin_reload = plugin_subparsers.add_parser('reload', help='Reload plugin')
    plugin_reload.add_argument('name', help='Plugin name')

    # Sync commands
    sync_parser = subparsers.add_parser('sync', help='Cloud sync operations')
    sync_subparsers = sync_parser.add_subparsers(dest='sync_cmd')

    sync_subparsers.add_parser('status', help='Check sync status')
    sync_subparsers.add_parser('push', help='Push to cloud')
    sync_subparsers.add_parser('pull', help='Pull from cloud')

    # Other commands
    events_parser = subparsers.add_parser('events', help='Show recent events')
    events_parser.add_argument('-n', '--limit', type=int, default=20, help='Number of events')

    subparsers.add_parser('status', help='Show system status')
    subparsers.add_parser('version', help='Show version info')

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        return

    cli = KoalasCLI()

    # Route to appropriate command
    try:
        if args.command == 'install':
            await cli.cmd_install(args.apps, args.yes, dry_run=getattr(args, 'dry_run', False))

        elif args.command == 'update':
            await cli.cmd_update(args.apps if args.apps else None, all=args.all)

        elif args.command == 'uninstall':
            await cli.cmd_uninstall(args.apps, args.yes)

        elif args.command == 'search':
            await cli.cmd_search(args.query)

        elif args.command == 'list':
            await cli.cmd_list(category=args.category, installed=args.installed)

        elif args.command == 'categories':
            await cli.cmd_categories()

        elif args.command == 'rollback':
            if args.rollback_cmd == 'list':
                await cli.cmd_rollback_list()
            elif args.rollback_cmd == 'create':
                await cli.cmd_rollback_create(args.name)
            elif args.rollback_cmd == 'restore':
                await cli.cmd_rollback_restore(args.id)
            else:
                rollback_parser.print_help()

        elif args.command == 'plugin':
            if args.plugin_cmd == 'list':
                await cli.cmd_plugin_list()
            elif args.plugin_cmd == 'load':
                await cli.cmd_plugin_load(args.path)
            elif args.plugin_cmd == 'reload':
                await cli.cmd_plugin_reload(args.name)
            else:
                plugin_parser.print_help()

        elif args.command == 'sync':
            if args.sync_cmd == 'status':
                await cli.cmd_sync_status()
            elif args.sync_cmd == 'push':
                await cli.cmd_sync_push()
            elif args.sync_cmd == 'pull':
                await cli.cmd_sync_pull()
            else:
                sync_parser.print_help()

        elif args.command == 'events':
            await cli.cmd_events(args.limit)

        elif args.command == 'status':
            await cli.cmd_status()

        elif args.command == 'version':
            cli.cmd_version()

    except KeyboardInterrupt:
        print("\n\n‚ùå Cancelled by user")
        sys.exit(1)
    except Exception as e:
        print(f"\n‚ùå Error: {e}")
        sys.exit(1)


if __name__ == '__main__':
    asyncio.run(main())

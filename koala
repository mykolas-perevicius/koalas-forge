#!/usr/bin/env python3
"""
üê® Koala's Forge CLI Tool
A powerful command-line interface for managing your app installations.

Usage:
  koala install <app1> <app2> ...     Install applications (alias: i)
  koala update [app1] [app2] | --all  Update applications (aliases: u, upgrade)
  koala uninstall <app1> <app2>       Uninstall applications (aliases: remove, rm, r)
  koala list [--installed]            List available or installed apps (alias: ls)
  koala search <term>                 Search for applications (aliases: s, find)
  koala categories                    List all categories (alias: cat)
  koala info <package>                Show detailed package info (alias: show)

  koala preset <name>                 Install preset collections
  koala batch <file>                  Install from package list file
  koala export [output]               Export installed packages
  koala compare <file>                Compare current setup with file

  koala rollback list                 List rollback snapshots
  koala rollback create <name>        Create a new snapshot
  koala rollback restore <id>         Restore to a snapshot

  koala plugin list                   List loaded plugins
  koala plugin load <path>            Load a plugin
  koala plugin reload <name>          Reload a plugin

  koala sync push                     Push profile to cloud
  koala sync pull                     Pull profile from cloud
  koala sync status                   Check sync status

  koala events                        Show recent events (alias: log)
  koala status                        Show system status (alias: st)
  koala version                       Show version info (alias: v)
"""

import sys
import asyncio
import argparse
from pathlib import Path
from typing import List, Optional
import json

# Add src to path
sys.path.insert(0, str(Path(__file__).parent))

from src.core.event_system import EventBus, Event, EventType, get_event_bus
from src.core.plugin_system import PluginManager
from src.core.rollback_system import RollbackManager
from src.core.cloud_sync import CloudSyncManager
from src.core.installer import PackageInstaller, get_installer
from datetime import datetime


class KoalasCLI:
    """Main CLI application"""

    def __init__(self):
        self.event_bus = get_event_bus()
        self.plugin_manager = PluginManager(self.event_bus)
        self.rollback_manager = RollbackManager()
        self.cloud_sync = CloudSyncManager()
        self.installer = get_installer()
        self.version = "1.2.2"

    async def cmd_install(self, apps: List[str], yes: bool = False, dry_run: bool = False):
        """Install applications"""
        print(f"üê® Installing {len(apps)} application(s)...")

        if dry_run:
            print("üîç DRY RUN MODE - No actual changes will be made\n")

        # Create rollback point (unless dry run)
        if not dry_run:
            snapshot_id = await self.rollback_manager.create_snapshot(f"Before installing {', '.join(apps)}")
            print(f"üì∏ Created snapshot: {snapshot_id}\n")

        installed = []
        failed = []
        already_installed = []

        for app in apps:
            result = await self.installer.install(app, dry_run=dry_run)

            if result.get('success'):
                if result.get('already_installed'):
                    already_installed.append(app)
                else:
                    installed.append(app)
            else:
                failed.append((app, result.get('error', 'Unknown error')))
                print(f"  ‚ùå Failed to install {app}: {result.get('error')}")

        # Summary
        print(f"\n‚ú® Installation complete!")
        if installed:
            print(f"   Installed: {len(installed)} app(s)")
        if already_installed:
            print(f"   Already installed: {len(already_installed)} app(s)")
        if failed:
            print(f"   Failed: {len(failed)} app(s)")
            for app, error in failed:
                print(f"     - {app}: {error}")

    async def cmd_update(self, apps: Optional[List[str]] = None, all: bool = False):
        """Update applications"""
        if all:
            print("üê® Updating all installed applications...")
            # TODO: Get list of all installed apps
            print("  ‚ÑπÔ∏è  Update all not yet implemented")
            return

        if not apps:
            print("‚ùå Please specify apps to update or use --all")
            return

        print(f"üê® Updating {len(apps)} application(s)...")

        updated = []
        failed = []

        for app in apps:
            result = await self.installer.update(app)

            if result.get('success'):
                updated.append(app)
            else:
                failed.append((app, result.get('error', 'Unknown error')))

        # Summary
        print(f"\n‚ú® Update complete!")
        if updated:
            print(f"   Updated: {len(updated)} app(s)")
        if failed:
            print(f"   Failed: {len(failed)} app(s)")
            for app, error in failed:
                print(f"     - {app}: {error}")

    async def cmd_uninstall(self, apps: List[str], yes: bool = False):
        """Uninstall applications"""
        print(f"üê® Uninstalling {len(apps)} application(s)...")

        # Create rollback point
        snapshot_id = await self.rollback_manager.create_snapshot(f"Before uninstalling {', '.join(apps)}")
        print(f"üì∏ Created snapshot: {snapshot_id}\n")

        uninstalled = []
        failed = []
        not_installed = []

        for app in apps:
            result = await self.installer.uninstall(app)

            if result.get('success'):
                if result.get('not_installed'):
                    not_installed.append(app)
                else:
                    uninstalled.append(app)
            else:
                failed.append((app, result.get('error', 'Unknown error')))

        # Summary
        print(f"\n‚ú® Uninstall complete!")
        if uninstalled:
            print(f"   Uninstalled: {len(uninstalled)} app(s)")
        if not_installed:
            print(f"   Not installed: {len(not_installed)} app(s)")
        if failed:
            print(f"   Failed: {len(failed)} app(s)")
            for app, error in failed:
                print(f"     - {app}: {error}")

    async def cmd_search(self, query: str):
        """Search for applications"""
        results = self.installer.search_packages(query)

        if not results:
            print(f"No packages found matching '{query}'")
            return

        print(f"\nüîç Found {len(results)} package(s) matching '{query}':\n")
        print(f"{'Name':<30} {'Category':<20} {'Platforms'}")
        print("=" * 80)

        for pkg in results[:20]:  # Limit to 20 results
            platforms = ', '.join(pkg.platforms[:3])
            print(f"{pkg.name:<30} {pkg.category:<20} {platforms}")

            if pkg.notes:
                print(f"    {pkg.notes[:60]}")
                print()

        if len(results) > 20:
            print(f"\n... and {len(results) - 20} more results")

    async def cmd_list(self, category: Optional[str] = None, installed: bool = False):
        """List available or installed applications"""

        if installed:
            print("‚ÑπÔ∏è  Listing installed packages not yet implemented")
            return

        if category:
            print(f"\nüì¶ Packages in category '{category}':\n")
            packages = self.installer.list_packages(category=category)
        else:
            print(f"\nüì¶ All available packages:\n")
            packages = self.installer.list_packages()

        if not packages:
            print(f"No packages found")
            return

        # Group by category
        by_category = {}
        for pkg in packages:
            if pkg.category not in by_category:
                by_category[pkg.category] = []
            by_category[pkg.category].append(pkg)

        for cat, pkgs in sorted(by_category.items()):
            print(f"\n{cat.replace('_', ' ').title()} ({len(pkgs)} packages)")
            print("-" * 60)

            for pkg in pkgs[:10]:  # Limit per category
                platforms = ', '.join(pkg.platforms[:3])
                print(f"  ‚Ä¢ {pkg.name:<25} ({platforms})")

            if len(pkgs) > 10:
                print(f"    ... and {len(pkgs) - 10} more")

    async def cmd_categories(self):
        """List all package categories"""
        categories = self.installer.get_categories()

        print(f"\nüìÇ Available Categories ({len(categories)}):\n")

        for cat in categories:
            packages = self.installer.list_packages(category=cat)
            display_name = cat.replace('_', ' ').title()
            print(f"  ‚Ä¢ {display_name:<30} ({len(packages)} packages)")

        print(f"\nUse './koala list --category <name>' to see packages in a category")

    async def cmd_info(self, package_name: str):
        """Show detailed information about a package"""
        pkg = self.installer.get_package(package_name)

        if not pkg:
            print(f"‚ùå Package not found: {package_name}")
            print(f"\nTry: ./koala search {package_name}")
            return

        # Check if installed
        is_installed = await self.installer.is_installed(package_name)

        print(f"\n{'='*70}")
        print(f"üì¶ {pkg.name}")
        print(f"{'='*70}\n")

        print(f"Status:      {'‚úÖ Installed' if is_installed else '‚¨ú Not installed'}")
        print(f"Package:     {pkg.package}")
        print(f"Category:    {pkg.category.replace('_', ' ').title()}")
        print(f"Platforms:   {', '.join(pkg.platforms)}")
        print(f"Install via: {pkg.install_type}")
        print(f"Priority:    {pkg.priority}")

        if pkg.size:
            print(f"Size:        {pkg.size}")

        if pkg.version:
            print(f"Version:     {pkg.version}")

        if pkg.notes:
            print(f"\nDescription:")
            print(f"  {pkg.notes}")

        if pkg.pre_install:
            print(f"\n‚öôÔ∏è  Has pre-install script")

        if pkg.post_install:
            print(f"‚öôÔ∏è  Has post-install script")

        print(f"\n{'='*70}")

        if not is_installed:
            print(f"\nTo install: ./koala install {package_name}")
        else:
            print(f"\nTo update:    ./koala update {package_name}")
            print(f"To uninstall: ./koala uninstall {package_name}")

    async def cmd_preset(self, preset_name: str, dry_run: bool = False):
        """Install a preset collection of packages"""
        presets = {
            'dev-essentials': {
                'name': 'Development Essentials',
                'packages': ['git', 'python-3.11', 'node.js', 'docker'],
                'description': 'Core development tools for any developer'
            },
            'ai-developer': {
                'name': 'AI Developer Pack',
                'packages': ['python-3.11', 'ollama', 'jupyter', 'git'],
                'description': 'Tools for AI and machine learning development'
            },
            'full-stack': {
                'name': 'Full Stack Developer',
                'packages': ['git', 'node.js', 'python-3.11', 'docker', 'postgresql', 'redis'],
                'description': 'Complete full-stack development environment'
            },
            'creative': {
                'name': 'Creative Suite',
                'packages': ['gimp', 'inkscape', 'blender', 'audacity'],
                'description': 'Tools for creative professionals'
            },
            'security': {
                'name': 'Security Tools',
                'packages': ['wireshark', 'nmap', 'burp-suite', '1password'],
                'description': 'Security and privacy tools'
            }
        }

        if preset_name == 'list':
            print(f"\nüìã Available Presets:\n")
            for key, preset in presets.items():
                print(f"  ‚Ä¢ {key}")
                print(f"    {preset['name']} - {preset['description']}")
                print(f"    Packages: {', '.join(preset['packages'][:4])}")
                if len(preset['packages']) > 4:
                    print(f"              ... and {len(preset['packages']) - 4} more")
                print()
            print(f"Install a preset with: ./koala preset <name>")
            return

        if preset_name not in presets:
            print(f"‚ùå Unknown preset: {preset_name}")
            print(f"\nAvailable presets: {', '.join(presets.keys())}")
            print(f"Or use: ./koala preset list")
            return

        preset = presets[preset_name]

        print(f"\nüéØ Installing Preset: {preset['name']}")
        print(f"   {preset['description']}")
        print(f"   Packages: {len(preset['packages'])}\n")

        if dry_run:
            print("üîç DRY RUN MODE - No actual changes will be made\n")
            for pkg in preset['packages']:
                print(f"  ‚Ä¢ {pkg}")
            return

        # Install all packages in the preset
        await self.cmd_install(preset['packages'], yes=True, dry_run=False)

    async def cmd_batch(self, file_path: str, dry_run: bool = False):
        """Install packages from a file (one per line)"""
        try:
            with open(file_path, 'r') as f:
                lines = f.readlines()

            # Parse packages (skip comments and empty lines)
            packages = []
            for line in lines:
                line = line.strip()
                if line and not line.startswith('#'):
                    packages.append(line)

            if not packages:
                print(f"‚ùå No packages found in {file_path}")
                return

            print(f"üìÑ Batch installation from: {file_path}")
            print(f"   Found {len(packages)} package(s)\n")

            if dry_run:
                print("üîç DRY RUN MODE - Would install:\n")
                for pkg in packages:
                    print(f"  ‚Ä¢ {pkg}")
                return

            # Install all packages
            await self.cmd_install(packages, yes=True, dry_run=False)

        except FileNotFoundError:
            print(f"‚ùå File not found: {file_path}")
        except Exception as e:
            print(f"‚ùå Error reading file: {e}")

    async def cmd_export(self, output_file: str = None):
        """Export list of installed packages to a file"""
        if not output_file:
            output_file = f"koala-setup-{datetime.now().strftime('%Y%m%d')}.txt"

        print(f"üì§ Exporting installed packages...\n")

        # Get all packages
        all_packages = self.installer.list_packages()

        # Check which ones are installed
        installed_packages = []
        for pkg in all_packages:
            if await self.installer.is_installed(pkg.name.lower().replace(' ', '-')):
                installed_packages.append(pkg)

        if not installed_packages:
            print("‚ùå No installed packages found")
            return

        # Write to file
        try:
            with open(output_file, 'w') as f:
                f.write(f"# Koala's Forge Setup - {datetime.now().strftime('%Y-%m-%d %H:%M')}\n")
                f.write(f"# Installed packages: {len(installed_packages)}\n")
                f.write(f"# To restore: ./koala batch {output_file}\n\n")

                # Group by category
                by_category = {}
                for pkg in installed_packages:
                    if pkg.category not in by_category:
                        by_category[pkg.category] = []
                    by_category[pkg.category].append(pkg)

                for category in sorted(by_category.keys()):
                    f.write(f"\n# {category.replace('_', ' ').title()}\n")
                    for pkg in by_category[category]:
                        pkg_name = pkg.name.lower().replace(' ', '-')
                        f.write(f"{pkg_name}\n")

            print(f"‚úÖ Exported {len(installed_packages)} package(s) to: {output_file}")
            print(f"\nTo restore on another machine:")
            print(f"  ./koala batch {output_file}")
            print(f"\nTo sync via cloud:")
            print(f"  ./koala sync push")

        except Exception as e:
            print(f"‚ùå Error writing file: {e}")

    async def cmd_compare(self, file_path: str):
        """Compare current setup with a package list file"""
        try:
            with open(file_path, 'r') as f:
                lines = f.readlines()

            # Parse packages from file
            file_packages = set()
            for line in lines:
                line = line.strip()
                if line and not line.startswith('#'):
                    file_packages.add(line)

            # Get installed packages
            all_packages = self.installer.list_packages()
            installed_packages = set()
            for pkg in all_packages:
                pkg_name = pkg.name.lower().replace(' ', '-')
                if await self.installer.is_installed(pkg_name):
                    installed_packages.add(pkg_name)

            # Calculate differences
            missing = file_packages - installed_packages
            extra = installed_packages - file_packages
            common = file_packages & installed_packages

            print(f"\nüìä Comparing with: {file_path}\n")
            print(f"{'='*70}")
            print(f"In file:        {len(file_packages)} packages")
            print(f"Installed:      {len(installed_packages)} packages")
            print(f"Match:          {len(common)} packages")
            print(f"{'='*70}\n")

            if missing:
                print(f"‚ùå Missing ({len(missing)}):")
                for pkg in sorted(missing):
                    print(f"   ‚Ä¢ {pkg}")
                print()

            if extra:
                print(f"‚ûï Extra installed ({len(extra)}):")
                for pkg in sorted(extra)[:10]:  # Limit to 10
                    print(f"   ‚Ä¢ {pkg}")
                if len(extra) > 10:
                    print(f"   ... and {len(extra) - 10} more")
                print()

            if missing:
                print(f"To install missing packages:")
                print(f"  ./koala batch {file_path}")
            else:
                print(f"‚úÖ All packages from file are installed!")

        except FileNotFoundError:
            print(f"‚ùå File not found: {file_path}")
        except Exception as e:
            print(f"‚ùå Error: {e}")

    async def cmd_rollback_list(self):
        """List rollback snapshots"""
        snapshots = self.rollback_manager.list_snapshots()

        if not snapshots:
            print("No snapshots found. Create one with: koala rollback create <name>")
            return

        print(f"\nüì∏ Rollback Snapshots ({len(snapshots)})\n")
        print(f"{'ID':<25} {'Date':<20} {'Apps':<10} {'Description'}")
        print("=" * 80)

        for snapshot in snapshots:
            # Handle timestamp (could be string, float/unix timestamp, or datetime object)
            ts = snapshot['timestamp']
            if isinstance(ts, str):
                date = datetime.fromisoformat(ts).strftime('%Y-%m-%d %H:%M')
            elif isinstance(ts, (int, float)):
                date = datetime.fromtimestamp(ts).strftime('%Y-%m-%d %H:%M')
            else:
                date = ts.strftime('%Y-%m-%d %H:%M')

            apps_count = len(snapshot.get('installed_apps', []))
            desc = snapshot.get('description', 'No description')[:40]
            print(f"{snapshot['id']:<25} {date:<20} {apps_count:<10} {desc}")

    async def cmd_rollback_create(self, name: str):
        """Create a rollback snapshot"""
        snapshot_id = await self.rollback_manager.create_snapshot(name)
        print(f"‚úÖ Created snapshot: {snapshot_id}")
        print(f"   Description: {name}")

        # Get the snapshot to show details
        snapshots = self.rollback_manager.list_snapshots()
        snapshot = next((s for s in snapshots if s['id'] == snapshot_id), None)
        if snapshot:
            print(f"   Apps tracked: {len(snapshot.get('installed_apps', []))}")

    async def cmd_rollback_restore(self, snapshot_id: str):
        """Restore to a rollback snapshot"""
        print(f"üîÑ Restoring to snapshot: {snapshot_id}")

        result = await self.rollback_manager.rollback_to_snapshot(snapshot_id)

        if result['success']:
            print(f"‚úÖ Rollback successful!")
            print(f"   Removed: {len(result['removed'])} apps")
            print(f"   Added: {len(result['added'])} apps")

            if result['removed']:
                print("\n   Removed apps:")
                for app in result['removed']:
                    print(f"     - {app}")

            if result['added']:
                print("\n   Added apps:")
                for app in result['added']:
                    print(f"     + {app}")
        else:
            print(f"‚ùå Rollback failed: {result.get('error', 'Unknown error')}")

    async def cmd_plugin_list(self):
        """List loaded plugins"""
        await self.plugin_manager.load_all_plugins()
        plugins = self.plugin_manager.list_plugins()

        if not plugins:
            print("No plugins loaded. Add plugins to ~/.koalas-forge/plugins/")
            return

        print(f"\nüîå Loaded Plugins ({len(plugins)})\n")
        print(f"{'Name':<25} {'Version':<10} {'Status'}")
        print("=" * 60)

        for plugin in plugins:
            status = "‚úÖ Active" if plugin.get('enabled', True) else "‚è∏Ô∏è  Disabled"
            print(f"{plugin['name']:<25} {plugin.get('version', '1.0.0'):<10} {status}")

    async def cmd_plugin_load(self, path: str):
        """Load a plugin"""
        print(f"üîå Loading plugin: {path}")
        success = await self.plugin_manager.load_plugin(Path(path))

        if success:
            print(f"‚úÖ Plugin loaded successfully")
        else:
            print(f"‚ùå Failed to load plugin")

    async def cmd_plugin_reload(self, name: str):
        """Reload a plugin"""
        print(f"üîÑ Reloading plugin: {name}")
        success = await self.plugin_manager.reload_plugin(name)

        if success:
            print(f"‚úÖ Plugin reloaded successfully")
        else:
            print(f"‚ùå Failed to reload plugin")

    async def cmd_sync_status(self):
        """Check cloud sync status"""
        status = self.cloud_sync.get_status()

        print(f"\n‚òÅÔ∏è  Cloud Sync Status\n")
        print(f"Backend: {status['backend']}")
        print(f"Enabled: {'‚úÖ Yes' if status['enabled'] else '‚ùå No'}")
        print(f"Last sync: {status.get('last_sync', 'Never')}")

        if status['backend'] != 'none':
            print(f"Sync path: {status.get('sync_path', 'Not configured')}")

    async def cmd_sync_push(self):
        """Push profile to cloud"""
        print("‚òÅÔ∏è  Pushing profile to cloud...")

        # Create a profile from current state
        profile = {
            'name': 'current',
            'apps': [],  # Would get from system
            'timestamp': datetime.now().isoformat()
        }

        success = await self.cloud_sync.push_profile(profile)

        if success:
            print("‚úÖ Profile pushed to cloud successfully")
        else:
            print("‚ùå Failed to push profile")

    async def cmd_sync_pull(self):
        """Pull profile from cloud"""
        print("‚òÅÔ∏è  Pulling profile from cloud...")

        profile = await self.cloud_sync.pull_profile('current')

        if profile:
            print("‚úÖ Profile pulled from cloud successfully")
            print(f"   Apps: {len(profile.get('apps', []))}")
        else:
            print("‚ùå No profile found in cloud")

    async def cmd_events(self, limit: int = 20):
        """Show recent events"""
        history = self.event_bus.get_history(limit=limit)

        if not history:
            print("No events recorded yet.")
            return

        print(f"\nüìã Recent Events (last {len(history)})\n")
        print(f"{'Time':<20} {'Type':<30} {'Source':<15}")
        print("=" * 70)

        for event in history:
            time = datetime.fromisoformat(event.timestamp).strftime('%H:%M:%S')
            event_type = event.type.name if hasattr(event.type, 'name') else str(event.type)
            print(f"{time:<20} {event_type:<30} {event.source:<15}")

    async def cmd_status(self):
        """Show system status"""
        print(f"\nüê® Koala's Forge System Status\n")
        print(f"Version: {self.version}")

        # Event bus stats
        stats = self.event_bus.get_stats()
        print(f"\nEvent System:")
        print(f"  Handlers: {stats['sync_handlers']} sync, {stats['async_handlers']} async")
        print(f"  Events processed: {len(self.event_bus.get_history())}")

        # Plugins
        await self.plugin_manager.load_all_plugins()
        plugins = self.plugin_manager.list_plugins()
        print(f"\nPlugins:")
        print(f"  Loaded: {len(plugins)}")

        # Snapshots
        snapshots = self.rollback_manager.list_snapshots()
        print(f"\nRollback:")
        print(f"  Snapshots: {len(snapshots)}")

        # Sync
        sync_status = self.cloud_sync.get_status()
        print(f"\nCloud Sync:")
        print(f"  Backend: {sync_status['backend']}")
        print(f"  Enabled: {sync_status['enabled']}")

    def cmd_version(self):
        """Show version info"""
        print(f"üê® Koala's Forge v{self.version}")
        print(f"Event-Driven Architecture Release")
        print(f"\nFeatures:")
        print(f"  ‚úÖ Event System")
        print(f"  ‚úÖ Plugin System")
        print(f"  ‚úÖ Rollback System")
        print(f"  ‚úÖ Parallel Downloads")
        print(f"  ‚úÖ Cloud Sync")


async def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(
        description='üê® Koala\'s Forge - Modern application installer',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__
    )

    subparsers = parser.add_subparsers(dest='command', help='Command to run')

    # Install command
    install_parser = subparsers.add_parser('install', aliases=['i'], help='Install applications')
    install_parser.add_argument('apps', nargs='+', help='Applications to install')
    install_parser.add_argument('-y', '--yes', action='store_true', help='Skip confirmations')
    install_parser.add_argument('--dry-run', action='store_true', help='Simulate installation without making changes')

    # Update command
    update_parser = subparsers.add_parser('update', aliases=['u', 'upgrade'], help='Update applications')
    update_parser.add_argument('apps', nargs='*', help='Applications to update')
    update_parser.add_argument('--all', action='store_true', help='Update all installed applications')

    # Uninstall command
    uninstall_parser = subparsers.add_parser('uninstall', aliases=['remove', 'rm', 'r'], help='Uninstall applications')
    uninstall_parser.add_argument('apps', nargs='+', help='Applications to uninstall')
    uninstall_parser.add_argument('-y', '--yes', action='store_true', help='Skip confirmations')

    # Search command
    search_parser = subparsers.add_parser('search', aliases=['s', 'find'], help='Search for applications')
    search_parser.add_argument('query', help='Search query')

    # List command
    list_parser = subparsers.add_parser('list', aliases=['ls'], help='List available applications')
    list_parser.add_argument('--category', help='Filter by category')
    list_parser.add_argument('--installed', action='store_true', help='List only installed applications')

    # Categories command
    subparsers.add_parser('categories', aliases=['cat'], help='List all categories')

    # Info command
    info_parser = subparsers.add_parser('info', aliases=['show'], help='Show detailed package information')
    info_parser.add_argument('package', help='Package name')

    # Preset command
    preset_parser = subparsers.add_parser('preset', help='Install preset collections')
    preset_parser.add_argument('name', help='Preset name (use "list" to see available)')
    preset_parser.add_argument('--dry-run', action='store_true', help='Show what would be installed')

    # Batch command
    batch_parser = subparsers.add_parser('batch', help='Install from file')
    batch_parser.add_argument('file', help='File path with package names (one per line)')
    batch_parser.add_argument('--dry-run', action='store_true', help='Show what would be installed')

    # Export command
    export_parser = subparsers.add_parser('export', help='Export installed packages to file')
    export_parser.add_argument('output', nargs='?', help='Output file path (default: koala-setup-YYYYMMDD.txt)')

    # Compare command
    compare_parser = subparsers.add_parser('compare', help='Compare current setup with a file')
    compare_parser.add_argument('file', help='File to compare against')

    # Rollback commands
    rollback_parser = subparsers.add_parser('rollback', help='Rollback operations')
    rollback_subparsers = rollback_parser.add_subparsers(dest='rollback_cmd')

    rollback_subparsers.add_parser('list', help='List snapshots')

    rollback_create = rollback_subparsers.add_parser('create', help='Create snapshot')
    rollback_create.add_argument('name', help='Snapshot description')

    rollback_restore = rollback_subparsers.add_parser('restore', help='Restore snapshot')
    rollback_restore.add_argument('id', help='Snapshot ID')

    # Plugin commands
    plugin_parser = subparsers.add_parser('plugin', help='Plugin operations')
    plugin_subparsers = plugin_parser.add_subparsers(dest='plugin_cmd')

    plugin_subparsers.add_parser('list', help='List plugins')

    plugin_load = plugin_subparsers.add_parser('load', help='Load plugin')
    plugin_load.add_argument('path', help='Plugin file path')

    plugin_reload = plugin_subparsers.add_parser('reload', help='Reload plugin')
    plugin_reload.add_argument('name', help='Plugin name')

    # Sync commands
    sync_parser = subparsers.add_parser('sync', help='Cloud sync operations')
    sync_subparsers = sync_parser.add_subparsers(dest='sync_cmd')

    sync_subparsers.add_parser('status', help='Check sync status')
    sync_subparsers.add_parser('push', help='Push to cloud')
    sync_subparsers.add_parser('pull', help='Pull from cloud')

    # Other commands
    events_parser = subparsers.add_parser('events', aliases=['log'], help='Show recent events')
    events_parser.add_argument('-n', '--limit', type=int, default=20, help='Number of events')

    subparsers.add_parser('status', aliases=['st'], help='Show system status')
    subparsers.add_parser('version', aliases=['v'], help='Show version info')

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        return

    cli = KoalasCLI()

    # Route to appropriate command
    try:
        if args.command in ('install', 'i'):
            await cli.cmd_install(args.apps, args.yes, dry_run=getattr(args, 'dry_run', False))

        elif args.command in ('update', 'u', 'upgrade'):
            await cli.cmd_update(args.apps if args.apps else None, all=args.all)

        elif args.command in ('uninstall', 'remove', 'rm', 'r'):
            await cli.cmd_uninstall(args.apps, args.yes)

        elif args.command in ('search', 's', 'find'):
            await cli.cmd_search(args.query)

        elif args.command in ('list', 'ls'):
            await cli.cmd_list(category=args.category, installed=args.installed)

        elif args.command in ('categories', 'cat'):
            await cli.cmd_categories()

        elif args.command in ('info', 'show'):
            await cli.cmd_info(args.package)

        elif args.command == 'preset':
            await cli.cmd_preset(args.name, dry_run=getattr(args, 'dry_run', False))

        elif args.command == 'batch':
            await cli.cmd_batch(args.file, dry_run=getattr(args, 'dry_run', False))

        elif args.command == 'export':
            await cli.cmd_export(args.output)

        elif args.command == 'compare':
            await cli.cmd_compare(args.file)

        elif args.command == 'rollback':
            if args.rollback_cmd == 'list':
                await cli.cmd_rollback_list()
            elif args.rollback_cmd == 'create':
                await cli.cmd_rollback_create(args.name)
            elif args.rollback_cmd == 'restore':
                await cli.cmd_rollback_restore(args.id)
            else:
                rollback_parser.print_help()

        elif args.command == 'plugin':
            if args.plugin_cmd == 'list':
                await cli.cmd_plugin_list()
            elif args.plugin_cmd == 'load':
                await cli.cmd_plugin_load(args.path)
            elif args.plugin_cmd == 'reload':
                await cli.cmd_plugin_reload(args.name)
            else:
                plugin_parser.print_help()

        elif args.command == 'sync':
            if args.sync_cmd == 'status':
                await cli.cmd_sync_status()
            elif args.sync_cmd == 'push':
                await cli.cmd_sync_push()
            elif args.sync_cmd == 'pull':
                await cli.cmd_sync_pull()
            else:
                sync_parser.print_help()

        elif args.command in ('events', 'log'):
            await cli.cmd_events(args.limit)

        elif args.command in ('status', 'st'):
            await cli.cmd_status()

        elif args.command in ('version', 'v'):
            cli.cmd_version()

    except KeyboardInterrupt:
        print("\n\n‚ùå Cancelled by user")
        sys.exit(1)
    except Exception as e:
        print(f"\n‚ùå Error: {e}")
        sys.exit(1)


if __name__ == '__main__':
    asyncio.run(main())

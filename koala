#!/usr/bin/env python3
"""
üê® Koala's Forge CLI Tool
A powerful command-line interface for managing your app installations.

Usage:
  koala install <app1> <app2> ...     Install applications (alias: i)
  koala update [app1] [app2] | --all  Update applications (aliases: u, upgrade)
  koala uninstall <app1> <app2>       Uninstall applications (aliases: remove, rm, r)
  koala list [--installed]            List available or installed apps (alias: ls)
  koala search <term>                 Search for applications (aliases: s, find)
  koala categories                    List all categories (alias: cat)
  koala info <package>                Show detailed package info (alias: show)

  koala preset <name>                 Install preset collections
  koala batch <file>                  Install from package list file
  koala export [output]               Export installed packages
  koala compare <file>                Compare current setup with file

  koala rollback list                 List rollback snapshots
  koala rollback create <name>        Create a new snapshot
  koala rollback restore <id>         Restore to a snapshot

  koala plugin list                   List loaded plugins
  koala plugin load <path>            Load a plugin
  koala plugin reload <name>          Reload a plugin

  koala sync push                     Push profile to cloud
  koala sync pull                     Pull profile from cloud
  koala sync status                   Check sync status

  koala events                        Show recent events (alias: log)
  koala status                        Show system status (alias: st)
  koala version                       Show version info (alias: v)
"""

import sys
import asyncio
import argparse
from pathlib import Path
from typing import List, Optional
import json

# Add src to path
sys.path.insert(0, str(Path(__file__).parent))

from src.core.event_system import EventBus, Event, EventType, get_event_bus
from src.core.plugin_system import PluginManager
from src.core.rollback_system import RollbackManager
from src.core.cloud_sync import CloudSyncManager
from src.core.installer import PackageInstaller, get_installer
from src.core.config import Config, get_config
from src.core.updater import get_update_checker
from src.core.history import get_history
from src.core.history_privacy import get_enhanced_history
from src.core.self_test import get_self_test
from src.core.dependency_resolver import get_dependency_resolver
from datetime import datetime


class KoalasCLI:
    """Main CLI application"""

    def __init__(self):
        self.event_bus = get_event_bus()
        self.plugin_manager = PluginManager(self.event_bus)
        self.rollback_manager = RollbackManager()
        self.cloud_sync = CloudSyncManager()
        self.installer = get_installer()
        self.config = get_config()
        self.history = get_history()
        self.enhanced_history = get_enhanced_history()
        self.self_test = get_self_test()
        self.dependency_resolver = get_dependency_resolver()
        self.version = "1.9.0"

    async def cmd_install(self, apps: List[str], yes: bool = False, dry_run: bool = False, sequential: bool = False, force: bool = False):
        """Install applications with parallel-by-default and auto-fallback"""
        import time

        print(f"üê® Installing {len(apps)} application(s)...")

        if force:
            print(f"üí™ Force mode enabled - will reinstall even if already installed\n")

        if dry_run:
            print("üîç DRY RUN MODE - No actual changes will be made\n")

        # Create rollback point (unless dry run)
        if not dry_run:
            snapshot_id = await self.rollback_manager.create_snapshot(f"Before installing {', '.join(apps)}")
            print(f"üì∏ Created snapshot: {snapshot_id}\n")

        # Check dependencies (optional, can be disabled in config)
        if self.config.get('check_dependencies', True) and not dry_run:
            print(f"üîç Checking dependencies...")
            resolution = await self.dependency_resolver.resolve_dependencies(apps)

            if resolution.conflicts:
                print(f"\n‚ö†Ô∏è  Conflicts detected:")
                for pkg1, pkg2 in resolution.conflicts:
                    print(f"   ‚Ä¢ {pkg1} conflicts with {pkg2}")
                if not yes:
                    confirm = input("\nContinue anyway? (y/N): ")
                    if confirm.lower() != 'y':
                        print("‚ùå Installation cancelled")
                        return

            if resolution.missing:
                print(f"\nüì¶ Missing dependencies: {', '.join(resolution.missing)}")
                if not yes:
                    confirm = input("Install missing dependencies? (Y/n): ")
                    if confirm.lower() != 'n':
                        apps = resolution.install_order  # Use resolved order
                        print(f"Updated install order: {' ‚Üí '.join(apps)}\n")

        installed = []
        failed = []
        already_installed = []
        parallel_failed = False

        # Try parallel first (default) unless forced sequential or only 1 app
        if not sequential and len(apps) > 1:
            try:
                print(f"‚ö° Installing concurrently (parallel mode)...\n")
                start_time = time.time()

                # Install all apps concurrently
                tasks = [self.installer.install(app, dry_run=dry_run) for app in apps]
                results = await asyncio.gather(*tasks, return_exceptions=True)

                # Check for critical failures that warrant fallback
                critical_failures = 0
                for result in results:
                    if isinstance(result, Exception):
                        critical_failures += 1

                # If too many failures, retry sequentially
                if critical_failures > len(apps) * 0.5:  # More than 50% failed
                    print(f"\n‚ö†Ô∏è  Parallel mode encountered issues ({critical_failures} failures)")
                    print(f"üîÑ Retrying with sequential installation...\n")
                    parallel_failed = True
                else:
                    # Process results
                    for app, result in zip(apps, results):
                        if isinstance(result, Exception):
                            failed.append((app, str(result)))
                            print(f"  ‚ùå Failed to install {app}: {result}")
                        elif result.get('success'):
                            if result.get('already_installed'):
                                already_installed.append(app)
                            else:
                                installed.append(app)
                        else:
                            failed.append((app, result.get('error', 'Unknown error')))
                            print(f"  ‚ùå Failed to install {app}: {result.get('error')}")

                    elapsed = time.time() - start_time
                    print(f"\n‚ö° Parallel installation completed in {elapsed:.1f}s")

            except Exception as e:
                print(f"\n‚ö†Ô∏è  Parallel installation error: {e}")
                print(f"üîÑ Falling back to sequential installation...\n")
                parallel_failed = True

        # Sequential installation (fallback or forced)
        if sequential or len(apps) == 1 or parallel_failed:
            if parallel_failed:
                # Clear previous attempts
                installed.clear()
                failed.clear()
                already_installed.clear()

            if len(apps) == 1:
                print(f"Installing {apps[0]}...\n")
            elif not parallel_failed:
                print(f"üì¶ Installing sequentially...\n")

            for app in apps:
                result = await self.installer.install(app, dry_run=dry_run)

                if result.get('success'):
                    if result.get('already_installed'):
                        already_installed.append(app)
                    else:
                        installed.append(app)
                else:
                    failed.append((app, result.get('error', 'Unknown error')))
                    print(f"  ‚ùå Failed to install {app}: {result.get('error')}")

        # Summary
        print(f"\n‚ú® Installation complete!")
        if installed:
            print(f"   Installed: {len(installed)} app(s)")
        if already_installed:
            print(f"   Already installed: {len(already_installed)} app(s)")
        if failed:
            print(f"   Failed: {len(failed)} app(s)")
            for app, error in failed:
                print(f"     - {app}: {error}")

        # Track installation in history (only if not dry run)
        if not dry_run:
            for app in installed:
                self.history.add_entry(
                    package=app,
                    action='install',
                    success=True,
                    details={
                        'parallel': not sequential and len(apps) > 1,
                        'forced': force
                    }
                )

                # Enhanced history with breakage detection
                breakage = self.enhanced_history.record_action_with_state(
                    package=app,
                    action='install',
                    success=True,
                    details={'parallel': not sequential and len(apps) > 1}
                )
                if breakage:
                    print(f"\n‚ö†Ô∏è  WARNING: {app} may have broken {', '.join(breakage.affected_packages)}")
                    print(f"   Suggested fix: {breakage.recovery_action}")

            for app, error in failed:
                self.history.add_entry(
                    package=app,
                    action='install',
                    success=False,
                    details={'error': error}
                )

    async def cmd_update(self, apps: Optional[List[str]] = None, all: bool = False):
        """Update applications"""
        if all:
            print("üê® Updating all installed applications...")
            # TODO: Get list of all installed apps
            print("  ‚ÑπÔ∏è  Update all not yet implemented")
            return

        if not apps:
            print("‚ùå Please specify apps to update or use --all")
            return

        print(f"üê® Updating {len(apps)} application(s)...")

        updated = []
        failed = []

        for app in apps:
            result = await self.installer.update(app)

            if result.get('success'):
                updated.append(app)
            else:
                failed.append((app, result.get('error', 'Unknown error')))

        # Summary
        print(f"\n‚ú® Update complete!")
        if updated:
            print(f"   Updated: {len(updated)} app(s)")
        if failed:
            print(f"   Failed: {len(failed)} app(s)")
            for app, error in failed:
                print(f"     - {app}: {error}")

    async def cmd_uninstall(self, apps: List[str], yes: bool = False):
        """Uninstall applications"""
        print(f"üê® Uninstalling {len(apps)} application(s)...")

        # Create rollback point
        snapshot_id = await self.rollback_manager.create_snapshot(f"Before uninstalling {', '.join(apps)}")
        print(f"üì∏ Created snapshot: {snapshot_id}\n")

        uninstalled = []
        failed = []
        not_installed = []

        for app in apps:
            result = await self.installer.uninstall(app)

            if result.get('success'):
                if result.get('not_installed'):
                    not_installed.append(app)
                else:
                    uninstalled.append(app)
            else:
                failed.append((app, result.get('error', 'Unknown error')))

        # Summary
        print(f"\n‚ú® Uninstall complete!")
        if uninstalled:
            print(f"   Uninstalled: {len(uninstalled)} app(s)")
        if not_installed:
            print(f"   Not installed: {len(not_installed)} app(s)")
        if failed:
            print(f"   Failed: {len(failed)} app(s)")
            for app, error in failed:
                print(f"     - {app}: {error}")

    async def cmd_search(self, query: str, installed: bool = False, category: str = None):
        """Search for applications with optional filters"""
        results = self.installer.search_packages(query)

        # Apply category filter
        if category:
            results = [pkg for pkg in results if pkg.category == category]

        # Apply installed filter
        if installed:
            filtered_results = []
            for pkg in results:
                pkg_name = pkg.name.lower().replace(' ', '-')
                if await self.installer.is_installed(pkg_name):
                    filtered_results.append(pkg)
            results = filtered_results

        if not results:
            filters_msg = ""
            if installed:
                filters_msg += " (installed only)"
            if category:
                filters_msg += f" (category: {category})"
            print(f"No packages found matching '{query}'{filters_msg}")
            return

        print(f"\nüîç Found {len(results)} package(s) matching '{query}'")
        if installed:
            print(f"   (showing installed only)")
        if category:
            print(f"   (category: {category})")
        print()

        print(f"{'Status':<8} {'Name':<30} {'Category':<20} {'Platforms'}")
        print("=" * 88)

        for pkg in results[:20]:  # Limit to 20 results
            pkg_name = pkg.name.lower().replace(' ', '-')
            is_installed = await self.installer.is_installed(pkg_name)
            status = "‚úÖ" if is_installed else "‚¨ú"

            platforms = ', '.join(pkg.platforms[:3])
            print(f"{status:<8} {pkg.name:<30} {pkg.category:<20} {platforms}")

            if pkg.notes:
                print(f"    {pkg.notes[:60]}")
                print()

        if len(results) > 20:
            print(f"\n... and {len(results) - 20} more results")

    async def cmd_list(self, category: Optional[str] = None, installed: bool = False):
        """List available or installed applications"""

        if installed:
            print(f"\nüì¶ Checking installed packages...\n")

            # Get all packages
            all_packages = self.installer.list_packages(category=category)

            # Check which ones are installed
            installed_packages = []
            for pkg in all_packages:
                if await self.installer.is_installed(pkg.package):
                    installed_packages.append(pkg)

            if not installed_packages:
                print(f"No installed packages found{' in this category' if category else ''}")
                return

            # Group by category
            by_category = {}
            for pkg in installed_packages:
                if pkg.category not in by_category:
                    by_category[pkg.category] = []
                by_category[pkg.category].append(pkg)

            print(f"‚úÖ Found {len(installed_packages)} installed package(s)\n")

            for cat, pkgs in sorted(by_category.items()):
                print(f"\n{cat.replace('_', ' ').title()} ({len(pkgs)} packages)")
                print("-" * 60)

                for pkg in pkgs:
                    platforms = ', '.join(pkg.platforms[:3])
                    print(f"  ‚úÖ {pkg.name:<25} ({platforms})")

            return

        if category:
            print(f"\nüì¶ Packages in category '{category}':\n")
            packages = self.installer.list_packages(category=category)
        else:
            print(f"\nüì¶ All available packages:\n")
            packages = self.installer.list_packages()

        if not packages:
            print(f"No packages found")
            return

        # Group by category
        by_category = {}
        for pkg in packages:
            if pkg.category not in by_category:
                by_category[pkg.category] = []
            by_category[pkg.category].append(pkg)

        for cat, pkgs in sorted(by_category.items()):
            print(f"\n{cat.replace('_', ' ').title()} ({len(pkgs)} packages)")
            print("-" * 60)

            for pkg in pkgs[:10]:  # Limit per category
                platforms = ', '.join(pkg.platforms[:3])
                print(f"  ‚Ä¢ {pkg.name:<25} ({platforms})")

            if len(pkgs) > 10:
                print(f"    ... and {len(pkgs) - 10} more")

    async def cmd_categories(self):
        """List all package categories"""
        categories = self.installer.get_categories()

        print(f"\nüìÇ Available Categories ({len(categories)}):\n")

        for cat in categories:
            packages = self.installer.list_packages(category=cat)
            display_name = cat.replace('_', ' ').title()
            print(f"  ‚Ä¢ {display_name:<30} ({len(packages)} packages)")

        print(f"\nUse './koala list --category <name>' to see packages in a category")

    async def cmd_info(self, package_name: str):
        """Show detailed information about a package"""
        pkg = self.installer.get_package(package_name)

        if not pkg:
            print(f"‚ùå Package not found: {package_name}")
            print(f"\nTry: ./koala search {package_name}")
            return

        # Check if installed
        is_installed = await self.installer.is_installed(package_name)

        print(f"\n{'='*70}")
        print(f"üì¶ {pkg.name}")
        print(f"{'='*70}\n")

        print(f"Status:      {'‚úÖ Installed' if is_installed else '‚¨ú Not installed'}")
        print(f"Package:     {pkg.package}")
        print(f"Category:    {pkg.category.replace('_', ' ').title()}")
        print(f"Platforms:   {', '.join(pkg.platforms)}")
        print(f"Install via: {pkg.install_type}")
        print(f"Priority:    {pkg.priority}")

        if pkg.size:
            print(f"Size:        {pkg.size}")

        if pkg.version:
            print(f"Version:     {pkg.version}")

        if pkg.notes:
            print(f"\nDescription:")
            print(f"  {pkg.notes}")

        if pkg.pre_install:
            print(f"\n‚öôÔ∏è  Has pre-install script")

        if pkg.post_install:
            print(f"‚öôÔ∏è  Has post-install script")

        print(f"\n{'='*70}")

        if not is_installed:
            print(f"\nTo install: ./koala install {package_name}")
        else:
            print(f"\nTo update:    ./koala update {package_name}")
            print(f"To uninstall: ./koala uninstall {package_name}")

    async def cmd_preset(self, preset_name: str, dry_run: bool = False):
        """Install a preset collection of packages"""
        presets = {
            'dev-essentials': {
                'name': 'Development Essentials',
                'packages': ['git', 'python-3.11', 'node.js', 'docker'],
                'description': 'Core development tools for any developer'
            },
            'ai-developer': {
                'name': 'AI Developer Pack',
                'packages': ['python-3.11', 'ollama', 'jupyter', 'git'],
                'description': 'Tools for AI and machine learning development'
            },
            'full-stack': {
                'name': 'Full Stack Developer',
                'packages': ['git', 'node.js', 'python-3.11', 'docker', 'postgresql', 'redis'],
                'description': 'Complete full-stack development environment'
            },
            'creative': {
                'name': 'Creative Suite',
                'packages': ['gimp', 'inkscape', 'blender', 'audacity'],
                'description': 'Tools for creative professionals'
            },
            'security': {
                'name': 'Security Tools',
                'packages': ['wireshark', 'nmap', 'burp-suite', '1password'],
                'description': 'Security and privacy tools'
            }
        }

        if preset_name == 'list':
            print(f"\nüìã Available Presets:\n")
            for key, preset in presets.items():
                print(f"  ‚Ä¢ {key}")
                print(f"    {preset['name']} - {preset['description']}")
                print(f"    Packages: {', '.join(preset['packages'][:4])}")
                if len(preset['packages']) > 4:
                    print(f"              ... and {len(preset['packages']) - 4} more")
                print()
            print(f"Install a preset with: ./koala preset <name>")
            return

        if preset_name not in presets:
            print(f"‚ùå Unknown preset: {preset_name}")
            print(f"\nAvailable presets: {', '.join(presets.keys())}")
            print(f"Or use: ./koala preset list")
            return

        preset = presets[preset_name]

        print(f"\nüéØ Installing Preset: {preset['name']}")
        print(f"   {preset['description']}")
        print(f"   Packages: {len(preset['packages'])}\n")

        if dry_run:
            print("üîç DRY RUN MODE - No actual changes will be made\n")
            for pkg in preset['packages']:
                print(f"  ‚Ä¢ {pkg}")
            return

        # Install all packages in the preset
        await self.cmd_install(preset['packages'], yes=True, dry_run=False)

    async def cmd_batch(self, file_path: str, dry_run: bool = False):
        """Install packages from a file (one per line)"""
        try:
            with open(file_path, 'r') as f:
                lines = f.readlines()

            # Parse packages (skip comments and empty lines)
            packages = []
            for line in lines:
                line = line.strip()
                if line and not line.startswith('#'):
                    packages.append(line)

            if not packages:
                print(f"‚ùå No packages found in {file_path}")
                return

            print(f"üìÑ Batch installation from: {file_path}")
            print(f"   Found {len(packages)} package(s)\n")

            if dry_run:
                print("üîç DRY RUN MODE - Would install:\n")
                for pkg in packages:
                    print(f"  ‚Ä¢ {pkg}")
                return

            # Install all packages
            await self.cmd_install(packages, yes=True, dry_run=False)

        except FileNotFoundError:
            print(f"‚ùå File not found: {file_path}")
        except Exception as e:
            print(f"‚ùå Error reading file: {e}")

    async def cmd_import(self, file_path: str, dry_run: bool = False):
        """Import and install packages from a file (supports txt, json, yaml)"""
        try:
            # Auto-detect format from file extension
            format = 'txt'
            if '.' in file_path:
                ext = file_path.rsplit('.', 1)[1].lower()
                if ext in ['json', 'yaml', 'yml']:
                    format = 'yaml' if ext == 'yml' else ext

            print(f"üì• Importing packages from {format.upper()} file...\n")

            packages = []

            if format == 'json':
                with open(file_path, 'r') as f:
                    data = json.load(f)

                # Handle both flat list and structured format
                if isinstance(data, list):
                    packages = data
                elif isinstance(data, dict):
                    if 'packages' in data:
                        # Structured format
                        for category, pkgs in data['packages'].items():
                            if isinstance(pkgs, list):
                                for pkg in pkgs:
                                    if isinstance(pkg, dict):
                                        packages.append(pkg.get('package', pkg.get('name', '')))
                                    else:
                                        packages.append(str(pkg))
                    else:
                        # Flat dict
                        packages = list(data.values())

            elif format == 'yaml':
                import yaml
                with open(file_path, 'r') as f:
                    data = yaml.safe_load(f)

                # Handle both flat list and structured format
                if isinstance(data, list):
                    packages = data
                elif isinstance(data, dict):
                    if 'packages' in data:
                        # Structured format
                        for category, pkgs in data['packages'].items():
                            if isinstance(pkgs, list):
                                packages.extend(pkgs)
                    else:
                        # Flat dict
                        packages = list(data.values())

            else:  # txt format
                with open(file_path, 'r') as f:
                    lines = f.readlines()

                # Parse packages (skip comments and empty lines)
                for line in lines:
                    line = line.strip()
                    if line and not line.startswith('#'):
                        packages.append(line)

            if not packages:
                print(f"‚ùå No packages found in {file_path}")
                return

            # Clean up package names
            packages = [str(pkg).strip() for pkg in packages if pkg]
            packages = [pkg for pkg in packages if pkg]  # Remove empty strings

            print(f"üìÑ Import summary:")
            print(f"   File: {file_path}")
            print(f"   Format: {format.upper()}")
            print(f"   Packages: {len(packages)}\n")

            if dry_run:
                print("üîç DRY RUN MODE - Would install:\n")
                for pkg in packages[:20]:  # Show first 20
                    print(f"  ‚Ä¢ {pkg}")
                if len(packages) > 20:
                    print(f"  ... and {len(packages) - 20} more")
                return

            # Install all packages
            await self.cmd_install(packages, yes=True, dry_run=False)

        except FileNotFoundError:
            print(f"‚ùå File not found: {file_path}")
        except ImportError as e:
            if 'yaml' in str(e):
                print(f"‚ùå YAML support requires PyYAML: pip install pyyaml")
            else:
                print(f"‚ùå Error: {e}")
        except json.JSONDecodeError as e:
            print(f"‚ùå Invalid JSON format: {e}")
        except Exception as e:
            print(f"‚ùå Error reading file: {e}")

    async def cmd_export(self, output_file: str = None, format: str = "txt"):
        """Export list of installed packages to a file"""
        # Auto-detect format from file extension if not specified
        if output_file and '.' in output_file:
            ext = output_file.rsplit('.', 1)[1].lower()
            if ext in ['json', 'yaml', 'yml', 'txt']:
                format = 'yaml' if ext == 'yml' else ext

        if not output_file:
            output_file = f"koala-setup-{datetime.now().strftime('%Y%m%d')}.{format}"

        print(f"üì§ Exporting installed packages to {format.upper()} format...\n")

        # Get all packages
        all_packages = self.installer.list_packages()

        # Check which ones are installed
        installed_packages = []
        for pkg in all_packages:
            if await self.installer.is_installed(pkg.name.lower().replace(' ', '-')):
                installed_packages.append(pkg)

        if not installed_packages:
            print("‚ùå No installed packages found")
            return

        # Group by category
        by_category = {}
        for pkg in installed_packages:
            if pkg.category not in by_category:
                by_category[pkg.category] = []
            by_category[pkg.category].append(pkg)

        # Write to file
        try:
            if format == 'json':
                # JSON format
                export_data = {
                    'metadata': {
                        'exported_at': datetime.now().isoformat(),
                        'total_packages': len(installed_packages),
                        'koala_version': self.version
                    },
                    'packages': {}
                }

                for category in sorted(by_category.keys()):
                    export_data['packages'][category] = [
                        {
                            'name': pkg.name,
                            'package': pkg.name.lower().replace(' ', '-'),
                            'platforms': pkg.platforms,
                            'install_type': pkg.install_type
                        }
                        for pkg in by_category[category]
                    ]

                with open(output_file, 'w') as f:
                    json.dump(export_data, f, indent=2)

            elif format == 'yaml':
                # YAML format
                import yaml
                export_data = {
                    'metadata': {
                        'exported_at': datetime.now().isoformat(),
                        'total_packages': len(installed_packages),
                        'koala_version': self.version
                    },
                    'packages': {}
                }

                for category in sorted(by_category.keys()):
                    export_data['packages'][category] = [
                        pkg.name.lower().replace(' ', '-')
                        for pkg in by_category[category]
                    ]

                with open(output_file, 'w') as f:
                    yaml.dump(export_data, f, default_flow_style=False, sort_keys=False)

            else:  # txt format (default)
                with open(output_file, 'w') as f:
                    f.write(f"# Koala's Forge Setup - {datetime.now().strftime('%Y-%m-%d %H:%M')}\n")
                    f.write(f"# Installed packages: {len(installed_packages)}\n")
                    f.write(f"# To restore: ./koala batch {output_file}\n")
                    f.write(f"# Or: ./koala import {output_file}\n\n")

                    for category in sorted(by_category.keys()):
                        f.write(f"\n# {category.replace('_', ' ').title()}\n")
                        for pkg in by_category[category]:
                            pkg_name = pkg.name.lower().replace(' ', '-')
                            f.write(f"{pkg_name}\n")

            print(f"‚úÖ Exported {len(installed_packages)} package(s) to: {output_file}")
            print(f"\nTo restore on another machine:")
            print(f"  ./koala import {output_file}")
            print(f"  # or: ./koala batch {output_file}")
            print(f"\nTo sync via cloud:")
            print(f"  ./koala sync push")

        except ImportError as e:
            if 'yaml' in str(e):
                print(f"‚ùå YAML support requires PyYAML: pip install pyyaml")
            else:
                print(f"‚ùå Error: {e}")
        except Exception as e:
            print(f"‚ùå Error writing file: {e}")

    async def cmd_compare(self, file_path: str):
        """Compare current setup with a package list file"""
        try:
            with open(file_path, 'r') as f:
                lines = f.readlines()

            # Parse packages from file
            file_packages = set()
            for line in lines:
                line = line.strip()
                if line and not line.startswith('#'):
                    file_packages.add(line)

            # Get installed packages
            all_packages = self.installer.list_packages()
            installed_packages = set()
            for pkg in all_packages:
                pkg_name = pkg.name.lower().replace(' ', '-')
                if await self.installer.is_installed(pkg_name):
                    installed_packages.add(pkg_name)

            # Calculate differences
            missing = file_packages - installed_packages
            extra = installed_packages - file_packages
            common = file_packages & installed_packages

            print(f"\nüìä Comparing with: {file_path}\n")
            print(f"{'='*70}")
            print(f"In file:        {len(file_packages)} packages")
            print(f"Installed:      {len(installed_packages)} packages")
            print(f"Match:          {len(common)} packages")
            print(f"{'='*70}\n")

            if missing:
                print(f"‚ùå Missing ({len(missing)}):")
                for pkg in sorted(missing):
                    print(f"   ‚Ä¢ {pkg}")
                print()

            if extra:
                print(f"‚ûï Extra installed ({len(extra)}):")
                for pkg in sorted(extra)[:10]:  # Limit to 10
                    print(f"   ‚Ä¢ {pkg}")
                if len(extra) > 10:
                    print(f"   ... and {len(extra) - 10} more")
                print()

            if missing:
                print(f"To install missing packages:")
                print(f"  ./koala batch {file_path}")
            else:
                print(f"‚úÖ All packages from file are installed!")

        except FileNotFoundError:
            print(f"‚ùå File not found: {file_path}")
        except Exception as e:
            print(f"‚ùå Error: {e}")

    async def cmd_rollback_list(self):
        """List rollback snapshots"""
        snapshots = self.rollback_manager.list_snapshots()

        if not snapshots:
            print("No snapshots found. Create one with: koala rollback create <name>")
            return

        print(f"\nüì∏ Rollback Snapshots ({len(snapshots)})\n")
        print(f"{'ID':<25} {'Date':<20} {'Apps':<10} {'Description'}")
        print("=" * 80)

        for snapshot in snapshots:
            # Handle timestamp (could be string, float/unix timestamp, or datetime object)
            ts = snapshot['timestamp']
            if isinstance(ts, str):
                date = datetime.fromisoformat(ts).strftime('%Y-%m-%d %H:%M')
            elif isinstance(ts, (int, float)):
                date = datetime.fromtimestamp(ts).strftime('%Y-%m-%d %H:%M')
            else:
                date = ts.strftime('%Y-%m-%d %H:%M')

            apps_count = len(snapshot.get('installed_apps', []))
            desc = snapshot.get('description', 'No description')[:40]
            print(f"{snapshot['id']:<25} {date:<20} {apps_count:<10} {desc}")

    async def cmd_rollback_create(self, name: str):
        """Create a rollback snapshot"""
        snapshot_id = await self.rollback_manager.create_snapshot(name)
        print(f"‚úÖ Created snapshot: {snapshot_id}")
        print(f"   Description: {name}")

        # Get the snapshot to show details
        snapshots = self.rollback_manager.list_snapshots()
        snapshot = next((s for s in snapshots if s['id'] == snapshot_id), None)
        if snapshot:
            print(f"   Apps tracked: {len(snapshot.get('installed_apps', []))}")

    async def cmd_rollback_restore(self, snapshot_id: str):
        """Restore to a rollback snapshot"""
        print(f"üîÑ Restoring to snapshot: {snapshot_id}")

        result = await self.rollback_manager.rollback_to_snapshot(snapshot_id)

        if result['success']:
            print(f"‚úÖ Rollback successful!")
            print(f"   Removed: {len(result['removed'])} apps")
            print(f"   Added: {len(result['added'])} apps")

            if result['removed']:
                print("\n   Removed apps:")
                for app in result['removed']:
                    print(f"     - {app}")

            if result['added']:
                print("\n   Added apps:")
                for app in result['added']:
                    print(f"     + {app}")
        else:
            print(f"‚ùå Rollback failed: {result.get('error', 'Unknown error')}")

    async def cmd_plugin_list(self):
        """List loaded plugins"""
        await self.plugin_manager.load_all_plugins()
        plugins = self.plugin_manager.list_plugins()

        if not plugins:
            print("No plugins loaded. Add plugins to ~/.koalas-forge/plugins/")
            return

        print(f"\nüîå Loaded Plugins ({len(plugins)})\n")
        print(f"{'Name':<25} {'Version':<10} {'Status'}")
        print("=" * 60)

        for plugin in plugins:
            status = "‚úÖ Active" if plugin.get('enabled', True) else "‚è∏Ô∏è  Disabled"
            print(f"{plugin['name']:<25} {plugin.get('version', '1.0.0'):<10} {status}")

    async def cmd_plugin_load(self, path: str):
        """Load a plugin"""
        print(f"üîå Loading plugin: {path}")
        success = await self.plugin_manager.load_plugin(Path(path))

        if success:
            print(f"‚úÖ Plugin loaded successfully")
        else:
            print(f"‚ùå Failed to load plugin")

    async def cmd_plugin_reload(self, name: str):
        """Reload a plugin"""
        print(f"üîÑ Reloading plugin: {name}")
        success = await self.plugin_manager.reload_plugin(name)

        if success:
            print(f"‚úÖ Plugin reloaded successfully")
        else:
            print(f"‚ùå Failed to reload plugin")

    async def cmd_sync_status(self):
        """Check cloud sync status"""
        status = self.cloud_sync.get_status()

        print(f"\n‚òÅÔ∏è  Cloud Sync Status\n")
        print(f"Backend: {status['backend']}")
        print(f"Enabled: {'‚úÖ Yes' if status['enabled'] else '‚ùå No'}")
        print(f"Last sync: {status.get('last_sync', 'Never')}")

        if status['backend'] != 'none':
            print(f"Sync path: {status.get('sync_path', 'Not configured')}")

    async def cmd_sync_push(self):
        """Push profile to cloud"""
        print("‚òÅÔ∏è  Pushing profile to cloud...")

        # Create a profile from current state
        profile = {
            'name': 'current',
            'apps': [],  # Would get from system
            'timestamp': datetime.now().isoformat()
        }

        success = await self.cloud_sync.push_profile(profile)

        if success:
            print("‚úÖ Profile pushed to cloud successfully")
        else:
            print("‚ùå Failed to push profile")

    async def cmd_sync_pull(self):
        """Pull profile from cloud"""
        print("‚òÅÔ∏è  Pulling profile from cloud...")

        profile = await self.cloud_sync.pull_profile('current')

        if profile:
            print("‚úÖ Profile pulled from cloud successfully")
            print(f"   Apps: {len(profile.get('apps', []))}")
        else:
            print("‚ùå No profile found in cloud")

    async def cmd_events(self, limit: int = 20):
        """Show recent events"""
        history = self.event_bus.get_history(limit=limit)

        if not history:
            print("No events recorded yet.")
            return

        print(f"\nüìã Recent Events (last {len(history)})\n")
        print(f"{'Time':<20} {'Type':<30} {'Source':<15}")
        print("=" * 70)

        for event in history:
            time = datetime.fromisoformat(event.timestamp).strftime('%H:%M:%S')
            event_type = event.type.name if hasattr(event.type, 'name') else str(event.type)
            print(f"{time:<20} {event_type:<30} {event.source:<15}")

    async def cmd_status(self):
        """Show system status"""
        print(f"\nüê® Koala's Forge System Status\n")
        print(f"Version: {self.version}")

        # Event bus stats
        stats = self.event_bus.get_stats()
        print(f"\nEvent System:")
        print(f"  Handlers: {stats['sync_handlers']} sync, {stats['async_handlers']} async")
        print(f"  Events processed: {len(self.event_bus.get_history())}")

        # Plugins
        await self.plugin_manager.load_all_plugins()
        plugins = self.plugin_manager.list_plugins()
        print(f"\nPlugins:")
        print(f"  Loaded: {len(plugins)}")

        # Snapshots
        snapshots = self.rollback_manager.list_snapshots()
        print(f"\nRollback:")
        print(f"  Snapshots: {len(snapshots)}")

        # Sync
        sync_status = self.cloud_sync.get_status()
        print(f"\nCloud Sync:")
        print(f"  Backend: {sync_status['backend']}")
        print(f"  Enabled: {sync_status['enabled']}")

    def cmd_version(self):
        """Show version info"""
        print(f"üê® Koala's Forge v{self.version}")
        print(f"Event-Driven Architecture Release")
        print(f"\nFeatures:")
        print(f"  ‚úÖ Event System")
        print(f"  ‚úÖ Plugin System")
        print(f"  ‚úÖ Rollback System")
        print(f"  ‚úÖ Parallel Downloads")
        print(f"  ‚úÖ Cloud Sync")

    async def cmd_health(self):
        """Check system health and dependencies"""
        import subprocess
        import shutil

        print(f"\nüè• Koala's Forge Health Check\n")

        # Check Python version
        py_version = sys.version.split()[0]
        print(f"Python: {py_version}", end="")
        if sys.version_info >= (3, 8):
            print(" ‚úÖ")
        else:
            print(" ‚ö†Ô∏è  (3.8+ recommended)")

        # Check OS
        os_name = self.installer.platform_info['os']
        print(f"Platform: {os_name} ‚úÖ")

        # Check package managers
        print(f"\nPackage Managers:")

        if os_name == "Darwin":  # macOS
            # Check Homebrew
            brew_path = shutil.which('brew')
            if brew_path:
                try:
                    result = subprocess.run(['brew', '--version'],
                                          capture_output=True, text=True, timeout=5)
                    version = result.stdout.split('\n')[0].replace('Homebrew ', '')
                    print(f"  Homebrew: {version} ‚úÖ")
                except:
                    print(f"  Homebrew: Found but version check failed ‚ö†Ô∏è")
            else:
                print(f"  Homebrew: Not found ‚ùå")
                print(f"    Install: /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"")

        elif os_name == "Linux":
            # Check apt
            apt_path = shutil.which('apt')
            if apt_path:
                try:
                    result = subprocess.run(['apt', '--version'],
                                          capture_output=True, text=True, timeout=5)
                    version = result.stdout.split('\n')[0]
                    print(f"  apt: {version} ‚úÖ")
                except:
                    print(f"  apt: Found ‚úÖ")
            else:
                print(f"  apt: Not found")

            # Check snap
            snap_path = shutil.which('snap')
            if snap_path:
                print(f"  snap: Found ‚úÖ")
            else:
                print(f"  snap: Not found")

        # Check dependencies
        print(f"\nKoala's Forge Components:")

        # Check apps.yaml
        apps_file = Path(__file__).parent / "apps.yaml"
        if apps_file.exists():
            print(f"  Package Database: {len(self.installer.packages_db)} packages ‚úÖ")
        else:
            print(f"  Package Database: Missing ‚ùå")

        # Check plugin directory
        plugin_dir = Path.home() / '.koalas-forge' / 'plugins'
        if plugin_dir.exists():
            plugin_count = len(list(plugin_dir.glob('*.py')))
            print(f"  Plugin Directory: {plugin_count} plugins ‚úÖ")
        else:
            print(f"  Plugin Directory: Not found (will be created) ‚ö†Ô∏è")

        # Check snapshots
        snapshot_count = len(self.rollback_manager.list_snapshots())
        print(f"  Rollback Snapshots: {snapshot_count} ‚úÖ")

        # Overall health
        print(f"\n{'='*50}")
        if os_name == "Darwin" and not shutil.which('brew'):
            print("‚ö†Ô∏è  Warning: Homebrew not found. Install it to use Koala's Forge.")
        elif os_name == "Linux" and not shutil.which('apt'):
            print("‚ö†Ô∏è  Warning: No supported package manager found.")
        else:
            print("‚úÖ System is healthy and ready to use!")

    async def cmd_config_show(self):
        """Show current configuration"""
        config_values = self.config.get_all()

        print(f"\n‚öôÔ∏è  Koala's Forge Configuration\n")
        print(f"Config file: {self.config.config_file}")
        print(f"{'='*50}\n")

        for key, value in config_values.items():
            print(f"  {key:<25} {value}")

        print(f"\nüí° Use 'koala config set <key> <value>' to change settings")
        print(f"üí° Use 'koala config init' to create default config file")

    async def cmd_config_get(self, key: str):
        """Get a configuration value"""
        value = self.config.get(key)

        if value is None:
            print(f"‚ùå Configuration key '{key}' not found")
            print(f"\nüí° Use 'koala config show' to see all available keys")
        else:
            print(f"{key} = {value}")

    async def cmd_config_set(self, key: str, value: str):
        """Set a configuration value"""
        # Try to convert value to appropriate type
        if value.lower() in ('true', 'yes', '1'):
            typed_value = True
        elif value.lower() in ('false', 'no', '0'):
            typed_value = False
        elif value.isdigit():
            typed_value = int(value)
        else:
            typed_value = value

        self.config.set(key, typed_value)

        if self.config.save_config():
            print(f"‚úÖ Set {key} = {typed_value}")
            print(f"üíæ Configuration saved to {self.config.config_file}")
        else:
            print(f"‚ùå Failed to save configuration")

    async def cmd_config_init(self):
        """Initialize configuration file with defaults"""
        if self.config.config_file.exists():
            print(f"‚ö†Ô∏è  Config file already exists: {self.config.config_file}")
            print(f"üí° Use 'koala config show' to view current configuration")
            return

        if self.config.create_default_config_file():
            print(f"‚úÖ Created default configuration file")
            print(f"üìÅ Location: {self.config.config_file}")
            print(f"\nüí° Edit the file directly or use 'koala config set <key> <value>'")
        else:
            print(f"‚ùå Failed to create configuration file")

    async def cmd_doctor(self, fix: bool = False):
        """Diagnose and optionally fix common issues"""
        import os
        import subprocess
        import shutil

        print(f"\nü©∫ Koala's Forge Doctor - Diagnosing issues...\n")

        issues_found = []
        fixes_applied = []

        # Check 1: Homebrew installation (macOS)
        os_name = self.installer.platform_info['os']
        if os_name == "Darwin":
            if not shutil.which('brew'):
                issues_found.append("Homebrew is not installed")
                if fix:
                    print("üîß Installing Homebrew...")
                    try:
                        subprocess.run(['/bin/bash', '-c',
                                      '$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)'],
                                     check=True)
                        fixes_applied.append("Installed Homebrew")
                    except:
                        print("  ‚ùå Failed to install Homebrew automatically")

        # Check 2: Plugin directory
        plugin_dir = Path.home() / '.koalas-forge' / 'plugins'
        if not plugin_dir.exists():
            issues_found.append("Plugin directory doesn't exist")
            if fix:
                plugin_dir.mkdir(parents=True, exist_ok=True)
                fixes_applied.append("Created plugin directory")

        # Check 3: Cache directory
        cache_dir = Path.home() / '.koalas-forge' / 'cache'
        if not cache_dir.exists():
            issues_found.append("Cache directory doesn't exist")
            if fix:
                cache_dir.mkdir(parents=True, exist_ok=True)
                fixes_applied.append("Created cache directory")

        # Check 4: Config file
        if not self.config.config_file.exists():
            issues_found.append("Configuration file doesn't exist")
            if fix:
                if self.config.create_default_config_file():
                    fixes_applied.append("Created default configuration file")

        # Check 5: Old/stale snapshots
        snapshots = self.rollback_manager.list_snapshots()
        if len(snapshots) > 50:
            issues_found.append(f"Too many snapshots ({len(snapshots)}), consider cleanup")

        # Check 6: Package database
        if len(self.installer.packages_db) == 0:
            issues_found.append("Package database is empty or failed to load")

        # Check 7: Permissions on koala script
        koala_script = Path(__file__)
        if not os.access(koala_script, os.X_OK):
            issues_found.append("Koala script is not executable")
            if fix:
                try:
                    koala_script.chmod(0o755)
                    fixes_applied.append("Made koala script executable")
                except:
                    print("  ‚ùå Failed to make koala executable")

        # Report findings
        print(f"{'='*60}")

        if not issues_found:
            print("‚úÖ No issues found! System is healthy.")
        else:
            print(f"Found {len(issues_found)} issue(s):\n")
            for i, issue in enumerate(issues_found, 1):
                print(f"  {i}. {issue}")

        if fix and fixes_applied:
            print(f"\nüîß Applied {len(fixes_applied)} fix(es):\n")
            for fix_msg in fixes_applied:
                print(f"  ‚úÖ {fix_msg}")

        if issues_found and not fix:
            print(f"\nüí° Run './koala doctor --fix' to automatically fix issues")

        print(f"{'='*60}")

    async def cmd_cleanup(self, keep: int = 10, dry_run: bool = False):
        """Clean up old rollback snapshots"""
        snapshots = self.rollback_manager.list_snapshots()

        if len(snapshots) <= keep:
            print(f"‚úÖ Only {len(snapshots)} snapshot(s) exist. Nothing to clean up.")
            print(f"   (Keeping the most recent {keep} snapshots)")
            return

        # Sort by timestamp (newest first)
        sorted_snapshots = sorted(snapshots, key=lambda x: x.get('timestamp', 0), reverse=True)

        # Keep the newest 'keep' snapshots
        to_keep = sorted_snapshots[:keep]
        to_delete = sorted_snapshots[keep:]

        print(f"\nüßπ Cleanup Report:")
        print(f"   Total snapshots: {len(snapshots)}")
        print(f"   Keeping: {len(to_keep)}")
        print(f"   Deleting: {len(to_delete)}")

        if dry_run:
            print(f"\nüîç DRY RUN - Would delete:")
        else:
            print(f"\nüóëÔ∏è  Deleting old snapshots:")

        for snapshot in to_delete:
            snapshot_id = snapshot.get('id', 'unknown')
            snapshot_name = snapshot.get('name', 'Unnamed')
            print(f"   ‚Ä¢ {snapshot_id}: {snapshot_name}")

            if not dry_run:
                try:
                    self.rollback_manager.delete_snapshot(snapshot_id)
                except:
                    print(f"     ‚ùå Failed to delete {snapshot_id}")

        if not dry_run:
            print(f"\n‚úÖ Cleanup complete!")
        else:
            print(f"\nüí° Run without --dry-run to actually delete")

    async def cmd_history(self, limit: int = 20, package: str = None, action: str = None):
        """View installation history"""
        print(f"\nüìú Installation History\n")

        if package:
            entries = self.history.get_entries_for_package(package)
            print(f"Showing history for: {package}\n")
        elif action:
            entries = self.history.get_entries_by_action(action)
            print(f"Showing {action} actions\n")
        else:
            entries = self.history.get_all_entries(limit=limit)

        if not entries:
            print("No history entries found")
            return

        print(f"{'='*80}")
        print(f"Showing {len(entries)} most recent entr{'ies' if len(entries) != 1 else 'y'}\n")

        for entry in entries:
            timestamp = datetime.fromisoformat(entry.timestamp)
            status = "‚úÖ" if entry.success else "‚ùå"
            action_icon = {"install": "üì¶", "update": "üîÑ", "uninstall": "üóëÔ∏è"}.get(entry.action, "‚Ä¢")

            print(f"{timestamp.strftime('%Y-%m-%d %H:%M:%S')} | {status} | {action_icon} {entry.action.upper():<10} | {entry.package}")

            if entry.details:
                details_str = ", ".join(f"{k}: {v}" for k, v in entry.details.items())
                print(f"  ‚Ü≥ {details_str}")

        # Show stats
        stats = self.history.get_stats()
        print(f"\n{'='*80}")
        print(f"üìä Statistics:")
        print(f"   Total operations: {stats['total']}")
        print(f"   Installs: {stats['installs']} | Updates: {stats['updates']} | Uninstalls: {stats['uninstalls']}")
        print(f"   Success rate: {stats['success_rate']:.1f}%")
        print(f"   Unique packages: {stats['unique_packages']}")

    async def cmd_verify(self, packages: List[str] = None):
        """Verify installed packages"""
        print(f"\nüîç Verifying installed packages...\n")

        if packages:
            # Verify specific packages
            to_verify = packages
        else:
            # Verify all packages in database
            all_packages = self.installer.list_packages()
            to_verify = [pkg.name.lower().replace(' ', '-') for pkg in all_packages]

        verified_count = 0
        installed_count = 0
        missing_count = 0
        missing_packages = []

        for pkg_name in to_verify:
            if await self.installer.is_installed(pkg_name):
                verified_count += 1
                installed_count += 1
                print(f"  ‚úÖ {pkg_name}")
            else:
                # Check if it was supposed to be installed
                last_action = self.history.get_last_action(pkg_name)
                if last_action and last_action.action == 'install' and last_action.success:
                    missing_count += 1
                    missing_packages.append(pkg_name)
                    print(f"  ‚ö†Ô∏è  {pkg_name} - Installed before but now missing!")

        print(f"\n{'='*80}")
        print(f"üìä Verification Results:")
        print(f"   Checked: {verified_count} packages")
        print(f"   Installed: {installed_count}")

        if missing_packages:
            print(f"   ‚ö†Ô∏è  Missing: {missing_count}")
            print(f"\n   Packages that were installed but are now missing:")
            for pkg in missing_packages:
                print(f"     - {pkg}")
            print(f"\n   üí° Run './koala install {' '.join(missing_packages)}' to reinstall")

    async def cmd_privacy(self, action: str = None, key: str = None, value: str = None):
        """Manage privacy settings for history tracking"""
        if not action or action == 'status':
            # Show privacy status
            report = self.enhanced_history.get_privacy_report()

            print(f"\nüîí Privacy Settings\n")
            print(f"{'='*80}")
            print(f"Tracking Enabled: {'‚úÖ Yes' if report['tracking_enabled'] else '‚ùå No'}")
            print(f"Anonymization: {'‚úÖ On' if report['anonymization'] else '‚ùå Off'}")
            print(f"Auto-clear: {report['auto_clear_days']} days" if report['auto_clear_days'] else "Auto-clear: Disabled")

            print(f"\nüìä Data Collected:")
            data = report['data_collected']
            print(f"   System states: {data['system_states']}")
            print(f"   Breakage events: {data['breakage_events']}")
            if data['oldest_entry']:
                print(f"   Oldest entry: {data['oldest_entry'][:10]}")
            print(f"   Storage used: {data.get('storage_size_kb', 0):.1f} KB")

            print(f"\nüí° Commands:")
            print(f"   ./koala privacy clear - Clear all history")
            print(f"   ./koala privacy disable - Disable tracking")
            print(f"   ./koala privacy enable - Enable tracking")
            print(f"   ./koala privacy set <key> <value> - Update setting")
            print(f"   ./koala privacy export - Export anonymized data")

        elif action == 'clear':
            print(f"\n‚ö†Ô∏è  WARNING: This will permanently delete all history data!")
            confirm = input("Type 'yes' to confirm: ")
            if confirm.lower() == 'yes':
                self.enhanced_history.clear_all_history(confirm=True)
            else:
                print("‚ùå Cancelled")

        elif action == 'disable':
            self.enhanced_history.privacy.set('tracking_enabled', False)
            print("‚úÖ History tracking disabled")

        elif action == 'enable':
            self.enhanced_history.privacy.set('tracking_enabled', True)
            print("‚úÖ History tracking enabled")

        elif action == 'set' and key and value:
            # Set a privacy configuration value
            if key in ['auto_clear_days']:
                value = int(value)
            elif key in ['anonymize_packages', 'track_system_state', 'track_performance']:
                value = value.lower() in ['true', 'yes', '1']

            self.enhanced_history.privacy.set(key, value)
            print(f"‚úÖ Set {key} = {value}")

        elif action == 'export':
            output_file = f"koala-privacy-export-{datetime.now().strftime('%Y%m%d')}.json"
            self.enhanced_history.export_anonymized(output_file)

        else:
            print("‚ùå Invalid privacy command. Use: status, clear, disable, enable, set, export")

    async def cmd_self_test(self, quick: bool = False):
        """Run self-tests to verify Koala's Forge is working correctly"""
        print(f"\nüß™ Running Self-Tests...\n")

        if quick:
            # Run only essential tests
            test_methods = [
                self.self_test.test_core_systems,
                self.self_test.test_cli_commands,
            ]
            suite_name = "Quick Test"
        else:
            # Run all tests
            suite = await self.self_test.run_all_tests()

            # Display results
            print(f"{'='*80}")
            print(f"üìä Test Results: {suite.summary()}\n")

            # Show failed tests
            failed_tests = [r for r in suite.results if not r.passed]
            if failed_tests:
                print(f"‚ùå Failed Tests:")
                for test in failed_tests:
                    print(f"   ‚Ä¢ {test.name}: {test.message}")
                print()

            # Show passed tests summary
            passed_tests = [r for r in suite.results if r.passed]
            if passed_tests:
                print(f"‚úÖ Passed {len(passed_tests)} test(s)")

            # Performance summary
            total_time = sum(r.duration_ms for r in suite.results)
            print(f"\n‚è±Ô∏è  Total test time: {total_time:.0f}ms")

            # Recommendations
            if not suite.passed:
                print(f"\nüí° Recommendations:")

                # Check for specific issues
                for test in failed_tests:
                    if 'Homebrew' in test.name:
                        print(f"   ‚Ä¢ Install Homebrew: /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"")
                    elif 'Memory' in test.name:
                        print(f"   ‚Ä¢ High memory usage detected. Consider restarting.")
                    elif 'Command' in test.name:
                        print(f"   ‚Ä¢ CLI commands failing. Run './koala doctor --fix'")

            return suite

    async def cmd_breakages(self, package: str = None, days: int = 7):
        """View recent breakage events"""
        print(f"\n‚ö†Ô∏è  Recent Breakage Events\n")

        if package:
            breakages = self.enhanced_history.get_breakages_by_package(package)
            print(f"Showing breakages caused by: {package}\n")
        else:
            breakages = self.enhanced_history.get_recent_breakages(days)
            print(f"Showing breakages from last {days} days\n")

        if not breakages:
            print("‚úÖ No breakages detected!")
            return

        print(f"{'='*80}")
        for b in breakages:
            timestamp = datetime.fromisoformat(b.timestamp)
            print(f"\n{timestamp.strftime('%Y-%m-%d %H:%M:%S')}")
            print(f"   Suspected cause: {b.suspected_cause}")
            print(f"   Affected: {', '.join(b.affected_packages)}")
            print(f"   Type: {b.error_type}")
            print(f"   Confidence: {b.confidence*100:.0f}%")
            if b.recovery_action:
                print(f"   üí° Suggested fix: {b.recovery_action}")

        print(f"\n{'='*80}")
        print(f"Total breakages: {len(breakages)}")

    async def cmd_deps(self, packages: List[str]):
        """Show dependencies for packages"""
        print(f"\nüîó Analyzing Dependencies\n")

        resolution = await self.dependency_resolver.resolve_dependencies(packages)

        # Show dependency graph
        viz = self.dependency_resolver.visualize_dependencies(packages)
        print(viz)
        print()

        # Show install order
        if resolution.install_order:
            print("üì¶ Install Order:")
            for i, pkg in enumerate(resolution.install_order, 1):
                print(f"   {i}. {pkg}")
            print()

        # Show conflicts
        if resolution.conflicts:
            print("‚ö†Ô∏è  Conflicts:")
            for pkg1, pkg2 in resolution.conflicts:
                print(f"   ‚Ä¢ {pkg1} ‚öîÔ∏è  {pkg2}")
            print()

        # Show optional dependencies
        if resolution.optional:
            print("üí° Optional Dependencies:")
            for opt in resolution.optional:
                print(f"   ‚Ä¢ {opt} (optional)")
            print()

        # Show replacements
        if resolution.replacements:
            print("üîÑ Replacements:")
            for old, new in resolution.replacements.items():
                print(f"   ‚Ä¢ {new} can replace {old}")

    async def cmd_recover(self, package: str):
        """Create recovery plan for broken package"""
        print(f"\nüöë Creating Recovery Plan for {package}\n")

        # Get recent error logs if available
        error_log = None
        recent_history = self.history.get_entries_for_package(package)
        for entry in recent_history[:10]:  # Get last 10 entries
            if not entry.success:
                error_log = entry.details.get('error') if entry.details else None
                break

        # Create recovery plan
        plan = await self.dependency_resolver.create_recovery_plan(package, error_log)

        print(f"Package: {plan.broken_package}")
        print(f"Root Cause: {plan.root_cause}")
        print(f"Confidence: {plan.confidence*100:.0f}%")
        print(f"Estimated Time: {plan.estimated_time}s\n")

        if plan.steps:
            print("üìã Recovery Steps:")
            for i, step in enumerate(plan.steps, 1):
                print(f"   {i}. {step}")
            print()

            print("üíª Commands to Execute:")
            for cmd in plan.commands:
                print(f"   $ {cmd}")
        else:
            print("‚ùå No recovery plan available")

    async def cmd_recommend(self):
        """Get smart package recommendations"""
        print(f"\n‚ú® Smart Package Recommendations\n")

        # Get installed packages
        installed = []
        for pkg_name in self.dependency_resolver.packages:
            if self.dependency_resolver.check_if_installed(pkg_name):
                installed.append(pkg_name)

        if not installed:
            print("No packages installed yet. Install some packages first!")
            return

        print(f"Based on your {len(installed)} installed packages:\n")

        # Get recommendations
        recommendations = await self.dependency_resolver.get_smart_recommendations(installed)

        if not recommendations:
            print("No recommendations at this time.")
            return

        print("üéØ Recommended Packages:")
        for i, (pkg, reason, score) in enumerate(recommendations[:10], 1):
            confidence = "‚≠ê" * int(score * 5)
            print(f"   {i:2}. {pkg:<20} {confidence}")
            print(f"       ‚Üí {reason}\n")


async def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(
        description='üê® Koala\'s Forge - Modern application installer',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__
    )

    subparsers = parser.add_subparsers(dest='command', help='Command to run')

    # Install command
    install_parser = subparsers.add_parser('install', aliases=['i'], help='Install applications')
    install_parser.add_argument('apps', nargs='+', help='Applications to install')
    install_parser.add_argument('-y', '--yes', action='store_true', help='Skip confirmations')
    install_parser.add_argument('--dry-run', action='store_true', help='Simulate installation without making changes')
    install_parser.add_argument('-s', '--sequential', action='store_true', help='Force sequential installation (parallel is default)')
    install_parser.add_argument('-f', '--force', action='store_true', help='Force reinstall even if already installed')

    # Update command
    update_parser = subparsers.add_parser('update', aliases=['u', 'upgrade'], help='Update applications')
    update_parser.add_argument('apps', nargs='*', help='Applications to update')
    update_parser.add_argument('--all', action='store_true', help='Update all installed applications')

    # Uninstall command
    uninstall_parser = subparsers.add_parser('uninstall', aliases=['remove', 'rm', 'r'], help='Uninstall applications')
    uninstall_parser.add_argument('apps', nargs='+', help='Applications to uninstall')
    uninstall_parser.add_argument('-y', '--yes', action='store_true', help='Skip confirmations')

    # Search command
    search_parser = subparsers.add_parser('search', aliases=['s', 'find'], help='Search for applications')
    search_parser.add_argument('query', help='Search query')
    search_parser.add_argument('--installed', action='store_true', help='Show only installed packages')
    search_parser.add_argument('--category', help='Filter by category')

    # List command
    list_parser = subparsers.add_parser('list', aliases=['ls'], help='List available applications')
    list_parser.add_argument('--category', help='Filter by category')
    list_parser.add_argument('--installed', action='store_true', help='List only installed applications')

    # Categories command
    subparsers.add_parser('categories', aliases=['cat'], help='List all categories')

    # Info command
    info_parser = subparsers.add_parser('info', aliases=['show'], help='Show detailed package information')
    info_parser.add_argument('package', help='Package name')

    # Preset command
    preset_parser = subparsers.add_parser('preset', help='Install preset collections')
    preset_parser.add_argument('name', help='Preset name (use "list" to see available)')
    preset_parser.add_argument('--dry-run', action='store_true', help='Show what would be installed')

    # Batch command
    batch_parser = subparsers.add_parser('batch', help='Install from file')
    batch_parser.add_argument('file', help='File path with package names (one per line)')
    batch_parser.add_argument('--dry-run', action='store_true', help='Show what would be installed')

    # Export command
    export_parser = subparsers.add_parser('export', help='Export installed packages to file')
    export_parser.add_argument('output', nargs='?', help='Output file path (default: koala-setup-YYYYMMDD.txt)')
    export_parser.add_argument('--format', choices=['txt', 'json', 'yaml'], default='txt', help='Export format (default: txt)')

    # Import command
    import_parser = subparsers.add_parser('import', help='Import and install packages from file (txt, json, yaml)')
    import_parser.add_argument('file', help='File to import from')
    import_parser.add_argument('--dry-run', action='store_true', help='Show what would be installed')

    # Compare command
    compare_parser = subparsers.add_parser('compare', help='Compare current setup with a file')
    compare_parser.add_argument('file', help='File to compare against')

    # Rollback commands
    rollback_parser = subparsers.add_parser('rollback', help='Rollback operations')
    rollback_subparsers = rollback_parser.add_subparsers(dest='rollback_cmd')

    rollback_subparsers.add_parser('list', help='List snapshots')

    rollback_create = rollback_subparsers.add_parser('create', help='Create snapshot')
    rollback_create.add_argument('name', help='Snapshot description')

    rollback_restore = rollback_subparsers.add_parser('restore', help='Restore snapshot')
    rollback_restore.add_argument('id', help='Snapshot ID')

    # Plugin commands
    plugin_parser = subparsers.add_parser('plugin', help='Plugin operations')
    plugin_subparsers = plugin_parser.add_subparsers(dest='plugin_cmd')

    plugin_subparsers.add_parser('list', help='List plugins')

    plugin_load = plugin_subparsers.add_parser('load', help='Load plugin')
    plugin_load.add_argument('path', help='Plugin file path')

    plugin_reload = plugin_subparsers.add_parser('reload', help='Reload plugin')
    plugin_reload.add_argument('name', help='Plugin name')

    # Sync commands
    sync_parser = subparsers.add_parser('sync', help='Cloud sync operations')
    sync_subparsers = sync_parser.add_subparsers(dest='sync_cmd')

    sync_subparsers.add_parser('status', help='Check sync status')
    sync_subparsers.add_parser('push', help='Push to cloud')
    sync_subparsers.add_parser('pull', help='Pull from cloud')

    # Config commands
    config_parser = subparsers.add_parser('config', help='Configuration management')
    config_subparsers = config_parser.add_subparsers(dest='config_cmd')

    config_subparsers.add_parser('show', help='Show all configuration')
    config_subparsers.add_parser('init', help='Create default config file')

    config_get = config_subparsers.add_parser('get', help='Get a config value')
    config_get.add_argument('key', help='Configuration key')

    config_set = config_subparsers.add_parser('set', help='Set a config value')
    config_set.add_argument('key', help='Configuration key')
    config_set.add_argument('value', help='Configuration value')

    # Other commands
    events_parser = subparsers.add_parser('events', aliases=['log'], help='Show recent events')
    events_parser.add_argument('-n', '--limit', type=int, default=20, help='Number of events')

    subparsers.add_parser('status', aliases=['st'], help='Show system status')
    subparsers.add_parser('health', help='Check system health and dependencies')

    # Doctor command
    doctor_parser = subparsers.add_parser('doctor', help='Diagnose and fix common issues')
    doctor_parser.add_argument('--fix', action='store_true', help='Automatically fix found issues')

    # Cleanup command
    cleanup_parser = subparsers.add_parser('cleanup', help='Clean up old rollback snapshots')
    cleanup_parser.add_argument('--keep', type=int, default=10, help='Number of snapshots to keep (default: 10)')
    cleanup_parser.add_argument('--dry-run', action='store_true', help='Show what would be deleted without deleting')

    # History command
    history_parser = subparsers.add_parser('history', help='View installation history')
    history_parser.add_argument('--limit', type=int, default=20, help='Number of entries to show (default: 20)')
    history_parser.add_argument('--package', help='Filter by package name')
    history_parser.add_argument('--action', choices=['install', 'update', 'uninstall'], help='Filter by action type')

    # Verify command
    verify_parser = subparsers.add_parser('verify', help='Verify installed packages')
    verify_parser.add_argument('packages', nargs='*', help='Specific packages to verify (default: all)')

    # Privacy command
    privacy_parser = subparsers.add_parser('privacy', help='Manage privacy settings')
    privacy_parser.add_argument('action', nargs='?', choices=['status', 'clear', 'disable', 'enable', 'set', 'export'], default='status', help='Privacy action')
    privacy_parser.add_argument('key', nargs='?', help='Setting key (for set action)')
    privacy_parser.add_argument('value', nargs='?', help='Setting value (for set action)')

    # Self-test command
    selftest_parser = subparsers.add_parser('self-test', help='Run self-tests')
    selftest_parser.add_argument('--quick', action='store_true', help='Run quick tests only')

    # Breakages command
    breakages_parser = subparsers.add_parser('breakages', help='View breakage events')
    breakages_parser.add_argument('--package', help='Filter by package')
    breakages_parser.add_argument('--days', type=int, default=7, help='Number of days to look back (default: 7)')

    # Dependency commands
    deps_parser = subparsers.add_parser('deps', help='Show dependencies for packages')
    deps_parser.add_argument('packages', nargs='+', help='Packages to analyze')

    recover_parser = subparsers.add_parser('recover', help='Create recovery plan for broken package')
    recover_parser.add_argument('package', help='Package to recover')

    subparsers.add_parser('recommend', help='Get smart package recommendations')

    subparsers.add_parser('version', aliases=['v'], help='Show version info')

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        return

    cli = KoalasCLI()

    # Check for updates (once per day, cached)
    try:
        updater = get_update_checker(cli.version)
        updater.notify_if_update_available()
    except:
        pass  # Don't let update check break the CLI

    # Route to appropriate command
    try:
        if args.command in ('install', 'i'):
            await cli.cmd_install(args.apps, args.yes,
                                dry_run=getattr(args, 'dry_run', False),
                                sequential=getattr(args, 'sequential', False),
                                force=getattr(args, 'force', False))

        elif args.command in ('update', 'u', 'upgrade'):
            await cli.cmd_update(args.apps if args.apps else None, all=args.all)

        elif args.command in ('uninstall', 'remove', 'rm', 'r'):
            await cli.cmd_uninstall(args.apps, args.yes)

        elif args.command in ('search', 's', 'find'):
            await cli.cmd_search(
                args.query,
                installed=getattr(args, 'installed', False),
                category=getattr(args, 'category', None)
            )

        elif args.command in ('list', 'ls'):
            await cli.cmd_list(category=args.category, installed=args.installed)

        elif args.command in ('categories', 'cat'):
            await cli.cmd_categories()

        elif args.command in ('info', 'show'):
            await cli.cmd_info(args.package)

        elif args.command == 'preset':
            await cli.cmd_preset(args.name, dry_run=getattr(args, 'dry_run', False))

        elif args.command == 'batch':
            await cli.cmd_batch(args.file, dry_run=getattr(args, 'dry_run', False))

        elif args.command == 'export':
            await cli.cmd_export(args.output, format=getattr(args, 'format', 'txt'))

        elif args.command == 'import':
            await cli.cmd_import(args.file, dry_run=getattr(args, 'dry_run', False))

        elif args.command == 'compare':
            await cli.cmd_compare(args.file)

        elif args.command == 'rollback':
            if args.rollback_cmd == 'list':
                await cli.cmd_rollback_list()
            elif args.rollback_cmd == 'create':
                await cli.cmd_rollback_create(args.name)
            elif args.rollback_cmd == 'restore':
                await cli.cmd_rollback_restore(args.id)
            else:
                rollback_parser.print_help()

        elif args.command == 'plugin':
            if args.plugin_cmd == 'list':
                await cli.cmd_plugin_list()
            elif args.plugin_cmd == 'load':
                await cli.cmd_plugin_load(args.path)
            elif args.plugin_cmd == 'reload':
                await cli.cmd_plugin_reload(args.name)
            else:
                plugin_parser.print_help()

        elif args.command == 'sync':
            if args.sync_cmd == 'status':
                await cli.cmd_sync_status()
            elif args.sync_cmd == 'push':
                await cli.cmd_sync_push()
            elif args.sync_cmd == 'pull':
                await cli.cmd_sync_pull()
            else:
                sync_parser.print_help()

        elif args.command == 'config':
            if args.config_cmd == 'show':
                await cli.cmd_config_show()
            elif args.config_cmd == 'get':
                await cli.cmd_config_get(args.key)
            elif args.config_cmd == 'set':
                await cli.cmd_config_set(args.key, args.value)
            elif args.config_cmd == 'init':
                await cli.cmd_config_init()
            else:
                config_parser.print_help()

        elif args.command in ('events', 'log'):
            await cli.cmd_events(args.limit)

        elif args.command in ('status', 'st'):
            await cli.cmd_status()

        elif args.command == 'health':
            await cli.cmd_health()

        elif args.command == 'doctor':
            await cli.cmd_doctor(fix=args.fix)

        elif args.command == 'cleanup':
            await cli.cmd_cleanup(keep=args.keep, dry_run=getattr(args, 'dry_run', False))

        elif args.command == 'history':
            await cli.cmd_history(
                limit=getattr(args, 'limit', 20),
                package=getattr(args, 'package', None),
                action=getattr(args, 'action', None)
            )

        elif args.command == 'verify':
            packages = getattr(args, 'packages', None)
            await cli.cmd_verify(packages if packages else None)

        elif args.command == 'privacy':
            if hasattr(args, 'privacy_cmd'):
                await cli.cmd_privacy(
                    action=args.privacy_cmd,
                    days=getattr(args, 'days', None)
                )
            else:
                await cli.cmd_privacy('status')

        elif args.command == 'self-test':
            await cli.cmd_self_test(
                quick=getattr(args, 'quick', False)
            )

        elif args.command == 'breakages':
            await cli.cmd_breakages(
                package=getattr(args, 'package', None),
                days=getattr(args, 'days', 7)
            )

        elif args.command == 'deps':
            await cli.cmd_deps(args.packages)

        elif args.command == 'recover':
            await cli.cmd_recover(args.package)

        elif args.command == 'recommend':
            await cli.cmd_recommend()

        elif args.command in ('version', 'v'):
            cli.cmd_version()

    except KeyboardInterrupt:
        print("\n\n‚ùå Cancelled by user")
        sys.exit(1)
    except Exception as e:
        print(f"\n‚ùå Error: {e}")
        sys.exit(1)


if __name__ == '__main__':
    asyncio.run(main())
